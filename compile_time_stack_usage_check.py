#!/usr/bin/python

"""
Checks stack usage in compiled .su files for functions exceeding a specified threshold.
Usage: ./compile_time_stack_usage_check.py --directory <directory> --threshold <threshold>
"""

import os
import sys
import argparse
import logging
from collections import defaultdict

# Constants
DEFAULT_THRESHOLD = 8192
COLUMN_WIDTH_FILE = 50
COLUMN_WIDTH_LINE = 10
COLUMN_WIDTH_FUNCTION = 40
COLUMN_WIDTH_BYTES = 10
HEADER_LINE_LENGTH = COLUMN_WIDTH_FILE + COLUMN_WIDTH_LINE + COLUMN_WIDTH_FUNCTION + COLUMN_WIDTH_BYTES + 3

# Messages
SCRIPT_DESCRIPTION = (
    "----------------------------------------\n"
    "Description:\n"
    "This script searches for .su files starting from the specified path and checks the stack usage of functions within these files.\n"
    "It reports functions that exceed the specified stack usage threshold.\n"
    "----------------------------------------\n"
)

REMINDERS = (
    "----------------------------------------\n"
    "Reminders:\n"
    "1. Compile your code with '-g -O0' for no optimization and '-fstack-usage' to create the .su files.\n"
    "2. This script checks stack usage at compile time and does not cover all scenarios as it does not run the code.\n"
    "3. .su files are generated by the compiler and contain information about the stack usage of functions.\n"
    "----------------------------------------\n"
)

# Check stack usage in .su files
def check_stack_usage(file_path, threshold):
    exceeded_functions = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                parts = line.split()
                if len(parts) > 2:
                    try:
                        stack_usage = int(parts[1])
                        if stack_usage > threshold:
                            exceeded_functions.append((parts[0], stack_usage))
                    except ValueError:
                        continue
    except IOError as e:
        logging.error("Failed to read file {}: {}".format(file_path, e))
    return exceeded_functions

# Find .su files in the given directory
def find_su_files(directory):
    su_files = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.su'):
                su_files.append(os.path.join(root, file))
    return su_files

# Process .su files and check stack usage
def process_su_files(directory, threshold):
    su_files = find_su_files(directory)
    exceeded_by_file = defaultdict(list)

    for su_file in su_files:
        base_name = os.path.basename(su_file)
        exceeded_functions = check_stack_usage(su_file, threshold)
        if exceeded_functions:
            for function, usage in exceeded_functions:
                function_parts = function.split(':')
                c_file_path = function_parts[0]
                line_number = function_parts[1]
                function_name = ':'.join(function_parts[2:])
                if len(function_parts) > 2 and function_parts[2].isdigit():
                    function_name = ':'.join(function_parts[3:])
                c_file_full_path = os.path.relpath(os.path.join(os.path.dirname(su_file), c_file_path), directory)
                exceeded_by_file[c_file_full_path].append((line_number, function_name, usage))
    return exceeded_by_file

# Print the results
def print_results(exceeded_by_file, su_files):
    print("{:<{}} {:<{}} {:<{}} {:>{}}".format("File", COLUMN_WIDTH_FILE, "Line", COLUMN_WIDTH_LINE, "Function", COLUMN_WIDTH_FUNCTION, "Bytes", COLUMN_WIDTH_BYTES))
    print("=" * HEADER_LINE_LENGTH)

    sorted_functions = sorted(
        ((file, line, function, usage) for file, functions in exceeded_by_file.items() for line, function, usage in functions),
        key=lambda x: x[3],
        reverse=True
    )

    for file, line, function, usage in sorted_functions:
        print("{:<{}} {:<{}} {:<{}} {:>{}}".format(file, COLUMN_WIDTH_FILE, line, COLUMN_WIDTH_LINE, function, COLUMN_WIDTH_FUNCTION, usage, COLUMN_WIDTH_BYTES))

    print("\nSummary:")
    print("Total number of .su files processed: {}".format(len(su_files)))
    print("Total number of files with functions exceeding the threshold: {}".format(len(exceeded_by_file)))
    total_exceeded = len(sorted_functions)
    print("Total number of functions that exceeded the stack usage threshold: {}\n".format(total_exceeded))

    return total_exceeded

# Main function
def main(directory, threshold):
    print(SCRIPT_DESCRIPTION)
    print(REMINDERS)
    print("Script will search in the path: {}\nStack usage threshold: {} bytes\n".format(directory, threshold))

    if threshold <= 0:
        logging.error("Threshold must be a positive integer.")
        sys.exit(1)

    su_files = find_su_files(directory)
    if not su_files:
        print("No .su files found in the specified directory.")
        sys.exit(1)

    exceeded_by_file = process_su_files(directory, threshold)
    total_exceeded = print_results(exceeded_by_file, su_files)
    if total_exceeded > 0:
        sys.exit(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Check stack usage in .su files.")
    parser.add_argument("--directory", type=str, default=os.path.abspath(os.getcwd()), help="Directory to search for .su files (default: current directory)")
    parser.add_argument("--threshold", type=int, default=DEFAULT_THRESHOLD, help="Stack usage threshold in bytes (default: {})".format(DEFAULT_THRESHOLD))

    args = parser.parse_args()
    
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
    
    main(args.directory, args.threshold)
