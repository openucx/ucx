/**
 * Copyright (c) UT-Battelle, LLC. 2014-2015. ALL RIGHTS RESERVED.
 * $COPYRIGHT$
 * $HEADER$
 */

#ifndef UCT_UGNI_CONTEXT_H
#define UCT_UGNI_CONTEXT_H

#include "ugni_device.h"

#include <uct/tl/context.h>


#define UCT_UGNI_MAX_DEVICES (2)

/**
 * @breif Static information about UGNI job
 *
 * This is static information about Cray's job.
 * The information is static and does not change since job launch.
 * Therefore, the information is only fetched once.
 */
typedef struct uct_ugni_job_info {
    uint8_t             ptag;                           /**< Protection tag */
    uint32_t            cookie;                         /**< Unique identifier generated by the PMI system */
    int                 pmi_num_of_ranks;               /**< Number of ranks started by PMI */
    int                 pmi_rank_id;                    /**< rank id assigned by PMI */
    int                 num_devices;                    /**< Number of devices */
    uct_ugni_device_t   devices[UCT_UGNI_MAX_DEVICES];  /**< Array of devices */
    bool                initialized;                    /**< Info status */
} uct_ugni_job_info_t;

extern uct_ugni_job_info_t job_info;
extern uct_pd_component_t uct_ugni_pd_component;

/**
 * @brief UGNI Protection domain
 *
 * Ugni does not define PD, instead I use
 * device handle that "simulates" the PD.
 * Memory that is registered with one device handle
 * can be accessed with any other.
 */
typedef struct uct_ugni_pd {
    struct uct_pd super;         /**< Domain info */
    gni_cdm_handle_t cdm_handle; /**< Ugni communication domain */
    gni_nic_handle_t nic_handle; /**< Ugni NIC handle */
    uint32_t address;            /**< UGNI address */
    int ref_count;               /**< UGNI Domain ref count */
} uct_ugni_pd_t;

/** @brief Global lock for the component */
extern pthread_mutex_t uct_ugni_global_lock;

/**
 * @brief Helper function to list UGNI resources
 */
uct_ugni_device_t * uct_ugni_device_by_name(const char *dev_name);
#endif
