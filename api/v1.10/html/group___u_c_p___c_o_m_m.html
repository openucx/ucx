<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UCX: UCP Communication routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="UCX_Logo_80x80.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UCX
   &#160;<span id="projectnumber">1.10</span>
   </div>
   <div id="projectbrief">Unified Communication X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___u_c_p___c_o_m_m.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UCP Communication routines<div class="ingroups"><a class="el" href="group___u_c_p___a_p_i.html">Unified Communication Protocol (UCP) API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structucp__err__handler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a></td></tr>
<tr class="memdesc:structucp__err__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP endpoint error handling context.  <a href="group___u_c_p___c_o_m_m.html#structucp__err__handler">More...</a><br /></td></tr>
<tr class="separator:structucp__err__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga55df42689ef1f5621eae4d1ffb16856e"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a></td></tr>
<tr class="memdesc:ga55df42689ef1f5621eae4d1ffb16856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Tag Identifier.  <a href="#ga55df42689ef1f5621eae4d1ffb16856e">More...</a><br /></td></tr>
<tr class="separator:ga55df42689ef1f5621eae4d1ffb16856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_recv_desc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a></td></tr>
<tr class="memdesc:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Message descriptor.  <a href="#ga6a8b5741a4e66d7e890d31ef7cbf88ec">More...</a><br /></td></tr>
<tr class="separator:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae461587956dd56a6bc7d67b027845891"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a></td></tr>
<tr class="memdesc:gae461587956dd56a6bc7d67b027845891"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Datatype Identifier.  <a href="#gae461587956dd56a6bc7d67b027845891">More...</a><br /></td></tr>
<tr class="separator:gae461587956dd56a6bc7d67b027845891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad905bbbff95166a1e9b0e9743feb677"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td></tr>
<tr class="memdesc:gaad905bbbff95166a1e9b0e9743feb677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking sends.  <a href="#gaad905bbbff95166a1e9b0e9743feb677">More...</a><br /></td></tr>
<tr class="separator:gaad905bbbff95166a1e9b0e9743feb677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee41a74074b37f96dad5b29c9af17faf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaee41a74074b37f96dad5b29c9af17faf">ucp_send_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, void *user_data)</td></tr>
<tr class="memdesc:gaee41a74074b37f96dad5b29c9af17faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking sends ucp_tag_send_nbx call.  <a href="#gaee41a74074b37f96dad5b29c9af17faf">More...</a><br /></td></tr>
<tr class="separator:gaee41a74074b37f96dad5b29c9af17faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf2174ce2b86eb56f6bd4bd62865e87f1">ucp_err_handler_cb_t</a>) (void *arg, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td></tr>
<tr class="memdesc:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to process peer failure.  <a href="#gaf2174ce2b86eb56f6bd4bd62865e87f1">More...</a><br /></td></tr>
<tr class="separator:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487a20aada512b312bc21757e368120d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga487a20aada512b312bc21757e368120d">ucp_err_handler_t</a></td></tr>
<tr class="memdesc:ga487a20aada512b312bc21757e368120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP endpoint error handling context.  <a href="#ga487a20aada512b312bc21757e368120d">More...</a><br /></td></tr>
<tr class="separator:ga487a20aada512b312bc21757e368120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length)</td></tr>
<tr class="memdesc:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking stream oriented receives.  <a href="#ga6a6234b8497006e26ba02f10ddc0bbf5">More...</a><br /></td></tr>
<tr class="separator:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e253400533137ba2a5a49a111a9ee8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf9e253400533137ba2a5a49a111a9ee8">ucp_stream_recv_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td></tr>
<tr class="memdesc:gaf9e253400533137ba2a5a49a111a9ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking stream receives ucp_stream_recv_nbx call.  <a href="#gaf9e253400533137ba2a5a49a111a9ee8">More...</a><br /></td></tr>
<tr class="separator:gaf9e253400533137ba2a5a49a111a9ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ac0fe5665d15fab5cd254af9b07758"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga00ac0fe5665d15fab5cd254af9b07758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking tag receives.  <a href="#ga00ac0fe5665d15fab5cd254af9b07758">More...</a><br /></td></tr>
<tr class="separator:ga00ac0fe5665d15fab5cd254af9b07758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e110cf7c85ed5f281bd52438488d75"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga70e110cf7c85ed5f281bd52438488d75">ucp_tag_recv_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *tag_info, void *user_data)</td></tr>
<tr class="memdesc:ga70e110cf7c85ed5f281bd52438488d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking tag receives ucp_tag_recv_nbx call.  <a href="#ga70e110cf7c85ed5f281bd52438488d75">More...</a><br /></td></tr>
<tr class="separator:ga70e110cf7c85ed5f281bd52438488d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242399982563973351591516039dd74b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga242399982563973351591516039dd74b">ucp_am_recv_data_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td></tr>
<tr class="memdesc:ga242399982563973351591516039dd74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking Active Message receives.  <a href="#ga242399982563973351591516039dd74b">More...</a><br /></td></tr>
<tr class="separator:ga242399982563973351591516039dd74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0">UCP_ATOMIC_POST_OP_ADD</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4">UCP_ATOMIC_POST_OP_AND</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460">UCP_ATOMIC_POST_OP_OR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89">UCP_ATOMIC_POST_OP_XOR</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d">UCP_ATOMIC_POST_OP_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_post.  <a href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">More...</a><br /></td></tr>
<tr class="separator:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037">UCP_ATOMIC_FETCH_OP_FADD</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069">UCP_ATOMIC_FETCH_OP_SWAP</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c">UCP_ATOMIC_FETCH_OP_CSWAP</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3">UCP_ATOMIC_FETCH_OP_FAND</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59">UCP_ATOMIC_FETCH_OP_FOR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049">UCP_ATOMIC_FETCH_OP_FXOR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05">UCP_ATOMIC_FETCH_OP_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_fetch.  <a href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">More...</a><br /></td></tr>
<tr class="separator:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2ee7516e48146c044e3d9e2a2ed380"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b">UCP_ATOMIC_OP_ADD</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb">UCP_ATOMIC_OP_SWAP</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a">UCP_ATOMIC_OP_CSWAP</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3">UCP_ATOMIC_OP_AND</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e">UCP_ATOMIC_OP_OR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243">UCP_ATOMIC_OP_XOR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380a0983496b62f2d28cf043966793c6bb0b">UCP_ATOMIC_OP_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:ga5c2ee7516e48146c044e3d9e2a2ed380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_op_nbx.  <a href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">More...</a><br /></td></tr>
<tr class="separator:ga5c2ee7516e48146c044e3d9e2a2ed380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c">UCP_STREAM_RECV_FLAG_WAITALL</a> = UCS_BIT(0)
 }</td></tr>
<tr class="memdesc:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to define behavior of <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> function.  <a href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">More...</a><br /></td></tr>
<tr class="separator:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fae646dd1668efba6efe49a35a6610"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996">UCP_OP_ATTR_FIELD_REQUEST</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602">UCP_OP_ATTR_FIELD_CALLBACK</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610af6f932f15331fe7c9efacbfe2578e5ec">UCP_OP_ATTR_FIELD_USER_DATA</a> = UCS_BIT(2), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a354ef92dd9352dfccc859cd2ca3558d8">UCP_OP_ATTR_FIELD_DATATYPE</a> = UCS_BIT(3), 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a2f2586686e21b2700fd7cd4a8efb5a1b">UCP_OP_ATTR_FIELD_FLAGS</a> = UCS_BIT(4), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0">UCP_OP_ATTR_FIELD_REPLY_BUFFER</a> = UCS_BIT(5), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a768b4c6759502c34b0051ba33c0d05b3">UCP_OP_ATTR_FIELD_MEMORY_TYPE</a> = UCS_BIT(6), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610ac5a4c17a81a2efefae5e338479ae06cb">UCP_OP_ATTR_FIELD_RECV_INFO</a> = UCS_BIT(7), 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a8805045d48573e9aa5751b439be114d0">UCP_OP_ATTR_FLAG_NO_IMM_CMPL</a> = UCS_BIT(16), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a69a2066ee5f68e57021f622b0cc859a8">UCP_OP_ATTR_FLAG_FAST_CMPL</a> = UCS_BIT(17), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610aeb35a090d86119cfd25d4e82753e943f">UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL</a> = UCS_BIT(18)
<br />
 }</td></tr>
<tr class="memdesc:ga67fae646dd1668efba6efe49a35a6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP operation fields and flags.  <a href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">More...</a><br /></td></tr>
<tr class="separator:ga67fae646dd1668efba6efe49a35a6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487a3c588a11e42b9f313f0c9e2ead3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga487a3c588a11e42b9f313f0c9e2ead3b">ucp_am_recv_attr_t</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#gga487a3c588a11e42b9f313f0c9e2ead3ba7a4057be7a4cc3bba470da4f8ed63259">UCP_AM_RECV_ATTR_FIELD_REPLY_EP</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga487a3c588a11e42b9f313f0c9e2ead3baf77ecce2987e81bf773a48363767b77e">UCP_AM_RECV_ATTR_FLAG_DATA</a> = UCS_BIT(16), 
<a class="el" href="group___u_c_p___c_o_m_m.html#gga487a3c588a11e42b9f313f0c9e2ead3baf9a8d75af5b826d7563863591a98714f">UCP_AM_RECV_ATTR_FLAG_RNDV</a> = UCS_BIT(17)
 }</td></tr>
<tr class="memdesc:ga487a3c588a11e42b9f313f0c9e2ead3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP AM receive data parameter fields and flags.  <a href="group___u_c_p___c_o_m_m.html#ga487a3c588a11e42b9f313f0c9e2ead3b">More...</a><br /></td></tr>
<tr class="separator:ga487a3c588a11e42b9f313f0c9e2ead3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae021145933ffa033b8327bb7bf2533"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaeae021145933ffa033b8327bb7bf2533">ucp_am_handler_param_field</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a4b9788659b793630cee9bc027add35ad">UCP_AM_HANDLER_PARAM_FIELD_ID</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a99854985610ec532f0c83e36b3cadb3d">UCP_AM_HANDLER_PARAM_FIELD_FLAGS</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a6c2a2d3fe9c7118d3513833ad452cb69">UCP_AM_HANDLER_PARAM_FIELD_CB</a> = UCS_BIT(2), 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a23622f1a9046a0b59d1519732e2b73ff">UCP_AM_HANDLER_PARAM_FIELD_ARG</a> = UCS_BIT(3)
 }</td></tr>
<tr class="memdesc:gaeae021145933ffa033b8327bb7bf2533"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP AM receive data parameters fields and flags.  <a href="group___u_c_p___c_o_m_m.html#gaeae021145933ffa033b8327bb7bf2533">More...</a><br /></td></tr>
<tr class="separator:gaeae021145933ffa033b8327bb7bf2533"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga94ec21811930b6b6fb8eab500b8c730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga94ec21811930b6b6fb8eab500b8c730d">ucp_am_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint16_t id, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb, unsigned flags)</td></tr>
<tr class="memdesc:ga94ec21811930b6b6fb8eab500b8c730d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Active Message.  <a href="#ga94ec21811930b6b6fb8eab500b8c730d">More...</a><br /></td></tr>
<tr class="separator:ga94ec21811930b6b6fb8eab500b8c730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8ab214f35828ee4608d73442e8c372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga4b8ab214f35828ee4608d73442e8c372">ucp_am_send_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, unsigned id, const void *header, size_t header_length, const void *buffer, size_t count, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga4b8ab214f35828ee4608d73442e8c372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Active Message.  <a href="#ga4b8ab214f35828ee4608d73442e8c372">More...</a><br /></td></tr>
<tr class="separator:ga4b8ab214f35828ee4608d73442e8c372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefaaa5e0a154efe496ae5bb7f2bf71f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaefaaa5e0a154efe496ae5bb7f2bf71f3">ucp_am_recv_data_nbx</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *data_desc, void *buffer, size_t count, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gaefaaa5e0a154efe496ae5bb7f2bf71f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Active Message sent with rendezvous protocol.  <a href="#gaefaaa5e0a154efe496ae5bb7f2bf71f3">More...</a><br /></td></tr>
<tr class="separator:gaefaaa5e0a154efe496ae5bb7f2bf71f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45570903fc3ce01e7e5c0cd241f516f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga45570903fc3ce01e7e5c0cd241f516f9">ucp_am_data_release</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *data)</td></tr>
<tr class="memdesc:ga45570903fc3ce01e7e5c0cd241f516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases Active Message data.  <a href="#ga45570903fc3ce01e7e5c0cd241f516f9">More...</a><br /></td></tr>
<tr class="separator:ga45570903fc3ce01e7e5c0cd241f516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga9022ff0ebb56cac81f6ba81bb28f71b3">ucp_stream_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb, unsigned flags)</td></tr>
<tr class="memdesc:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream send operation.  <a href="#ga9022ff0ebb56cac81f6ba81bb28f71b3">More...</a><br /></td></tr>
<tr class="separator:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fe6efe6b05e4e78f58bee68c68b252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae9fe6efe6b05e4e78f58bee68c68b252">ucp_stream_send_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gae9fe6efe6b05e4e78f58bee68c68b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream send operation.  <a href="#gae9fe6efe6b05e4e78f58bee68c68b252">More...</a><br /></td></tr>
<tr class="separator:gae9fe6efe6b05e4e78f58bee68c68b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7343bd638924e5518041311d5c1dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gaae7343bd638924e5518041311d5c1dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operations.  <a href="#gaae7343bd638924e5518041311d5c1dfc">More...</a><br /></td></tr>
<tr class="separator:gaae7343bd638924e5518041311d5c1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90aa964e14fef59b4e3bd9120cca669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, void *req)</td></tr>
<tr class="memdesc:gad90aa964e14fef59b4e3bd9120cca669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operations with user provided request.  <a href="#gad90aa964e14fef59b4e3bd9120cca669">More...</a><br /></td></tr>
<tr class="separator:gad90aa964e14fef59b4e3bd9120cca669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd3e1ccae2ef34463e8313d09d3db17f">ucp_tag_send_sync_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking synchronous tagged-send operation.  <a href="#gabd3e1ccae2ef34463e8313d09d3db17f">More...</a><br /></td></tr>
<tr class="separator:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8323878b60f426c630d4ff8996ede3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga8323878b60f426c630d4ff8996ede3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operation.  <a href="#ga8323878b60f426c630d4ff8996ede3cc">More...</a><br /></td></tr>
<tr class="separator:ga8323878b60f426c630d4ff8996ede3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d96a2aac42fe99ce0c79f15dda8bd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0d96a2aac42fe99ce0c79f15dda8bd06">ucp_tag_send_sync_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga0d96a2aac42fe99ce0c79f15dda8bd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking synchronous tagged-send operation.  <a href="#ga0d96a2aac42fe99ce0c79f15dda8bd06">More...</a><br /></td></tr>
<tr class="separator:ga0d96a2aac42fe99ce0c79f15dda8bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a> cb, size_t *length, unsigned flags)</td></tr>
<tr class="memdesc:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of structured data into a user-supplied buffer.  <a href="#gadf3b4504a329a46d2d4ec0a8cec08130">More...</a><br /></td></tr>
<tr class="separator:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30494ce33e63823c81c2c5b3656d25c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga30494ce33e63823c81c2c5b3656d25c3">ucp_stream_recv_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, size_t *length, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga30494ce33e63823c81c2c5b3656d25c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of structured data into a user-supplied buffer.  <a href="#ga30494ce33e63823c81c2c5b3656d25c3">More...</a><br /></td></tr>
<tr class="separator:ga30494ce33e63823c81c2c5b3656d25c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f307f4765eb5410f24ac27986b59d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, size_t *length)</td></tr>
<tr class="memdesc:ga47f307f4765eb5410f24ac27986b59d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of unstructured data into a UCP-supplied buffer.  <a href="#ga47f307f4765eb5410f24ac27986b59d7">More...</a><br /></td></tr>
<tr class="separator:ga47f307f4765eb5410f24ac27986b59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb24cdfc33dfb2886551b51843aa6304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a> cb)</td></tr>
<tr class="memdesc:gaeb24cdfc33dfb2886551b51843aa6304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <a href="#gaeb24cdfc33dfb2886551b51843aa6304">More...</a><br /></td></tr>
<tr class="separator:gaeb24cdfc33dfb2886551b51843aa6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">ucp_tag_recv_nbr</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, void *req)</td></tr>
<tr class="memdesc:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <a href="#ga5a86663a4a144fd81d7a4e3378c5edd2">More...</a><br /></td></tr>
<tr class="separator:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa842f8ca8ad1363ed857ab938285a16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gaa842f8ca8ad1363ed857ab938285a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <a href="#gaa842f8ca8ad1363ed857ab938285a16f">More...</a><br /></td></tr>
<tr class="separator:gaa842f8ca8ad1363ed857ab938285a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41668f468dc37a7634116b8210815f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, int remove, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga41668f468dc37a7634116b8210815f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking probe and return a message.  <a href="#ga41668f468dc37a7634116b8210815f22">More...</a><br /></td></tr>
<tr class="separator:ga41668f468dc37a7634116b8210815f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> message, <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a> cb)</td></tr>
<tr class="memdesc:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive operation for a probed message.  <a href="#gac335b3ae4c9577728d9c0f2ecd44c084">More...</a><br /></td></tr>
<tr class="separator:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c61d44f18362bdaf8fca3122efcea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga48c61d44f18362bdaf8fca3122efcea6">ucp_tag_msg_recv_nbx</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> message, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga48c61d44f18362bdaf8fca3122efcea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive operation for a probed message.  <a href="#ga48c61d44f18362bdaf8fca3122efcea6">More...</a><br /></td></tr>
<tr class="separator:ga48c61d44f18362bdaf8fca3122efcea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">ucp_put_nbi</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking implicit remote memory put operation.  <a href="#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">More...</a><br /></td></tr>
<tr class="separator:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba986b2bde69c215abd5766dbceeb18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga1ba986b2bde69c215abd5766dbceeb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory put operation.  <a href="#ga1ba986b2bde69c215abd5766dbceeb18">More...</a><br /></td></tr>
<tr class="separator:ga1ba986b2bde69c215abd5766dbceeb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e7b9b70b782140e63544b8613a5fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga29e7b9b70b782140e63544b8613a5fe7">ucp_put_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga29e7b9b70b782140e63544b8613a5fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory put operation.  <a href="#ga29e7b9b70b782140e63544b8613a5fe7">More...</a><br /></td></tr>
<tr class="separator:ga29e7b9b70b782140e63544b8613a5fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3597f699227d598651f6630fbd7968b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae3597f699227d598651f6630fbd7968b">ucp_get_nbi</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gae3597f699227d598651f6630fbd7968b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking implicit remote memory get operation.  <a href="#gae3597f699227d598651f6630fbd7968b">More...</a><br /></td></tr>
<tr class="separator:gae3597f699227d598651f6630fbd7968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga7cb68811f53a69d37fd16e8ddb46e23b">ucp_get_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory get operation.  <a href="#ga7cb68811f53a69d37fd16e8ddb46e23b">More...</a><br /></td></tr>
<tr class="separator:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06c6521592661a8123c11426074d880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa06c6521592661a8123c11426074d880">ucp_get_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gaa06c6521592661a8123c11426074d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory get operation.  <a href="#gaa06c6521592661a8123c11426074d880">More...</a><br /></td></tr>
<tr class="separator:gaa06c6521592661a8123c11426074d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839312fb4de5e786daacb4fa071d61df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a> opcode, uint64_t value, size_t op_size, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga839312fb4de5e786daacb4fa071d61df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic memory operation.  <a href="#ga839312fb4de5e786daacb4fa071d61df">More...</a><br /></td></tr>
<tr class="separator:ga839312fb4de5e786daacb4fa071d61df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a1a4a517797eb8c5c96ac8841437de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a> opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga43a1a4a517797eb8c5c96ac8841437de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic fetch operation.  <a href="#ga43a1a4a517797eb8c5c96ac8841437de">More...</a><br /></td></tr>
<tr class="separator:ga43a1a4a517797eb8c5c96ac8841437de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087e2cad02e84cf1230684362562aa46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a> opcode, const void *buffer, size_t count, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga087e2cad02e84cf1230684362562aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic memory operation.  <a href="#ga087e2cad02e84cf1230684362562aa46">More...</a><br /></td></tr>
<tr class="separator:ga087e2cad02e84cf1230684362562aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae082ad7af428645ebe6e469d3d06a757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a> (void *request)</td></tr>
<tr class="memdesc:gae082ad7af428645ebe6e469d3d06a757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of non-blocking request.  <a href="#gae082ad7af428645ebe6e469d3d06a757">More...</a><br /></td></tr>
<tr class="separator:gae082ad7af428645ebe6e469d3d06a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga707cbbef8cdcf90fa7cf63c922ef2c7f">ucp_tag_recv_request_test</a> (void *request, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status and currently available state of non-blocking request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> routine.  <a href="#ga707cbbef8cdcf90fa7cf63c922ef2c7f">More...</a><br /></td></tr>
<tr class="separator:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga4d8d8823b24cb25dcab8bf44c72fa25e">ucp_stream_recv_request_test</a> (void *request, size_t *length_p)</td></tr>
<tr class="memdesc:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status and currently available state of non-blocking request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> routine.  <a href="#ga4d8d8823b24cb25dcab8bf44c72fa25e">More...</a><br /></td></tr>
<tr class="separator:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga3553f89a61d6b40af4633a2e7c84fc1d">ucp_request_cancel</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *request)</td></tr>
<tr class="memdesc:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an outstanding communications request.  <a href="#ga3553f89a61d6b40af4633a2e7c84fc1d">More...</a><br /></td></tr>
<tr class="separator:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga1d1c1c1b2caf4f26c9872e1d708d5f68">ucp_stream_data_release</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *data)</td></tr>
<tr class="memdesc:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release UCP data buffer returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a>.  <a href="#ga1d1c1c1b2caf4f26c9872e1d708d5f68">More...</a><br /></td></tr>
<tr class="separator:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8e46f5953d464382b21edef3ec9994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> (void *request)</td></tr>
<tr class="memdesc:ga0e8e46f5953d464382b21edef3ec9994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a communications request.  <a href="#ga0e8e46f5953d464382b21edef3ec9994">More...</a><br /></td></tr>
<tr class="separator:ga0e8e46f5953d464382b21edef3ec9994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f75654d74e7e24881252fbff6bb9b2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac6f75654d74e7e24881252fbff6bb9b2">ucp_request_alloc</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:gac6f75654d74e7e24881252fbff6bb9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty communications request.  <a href="#gac6f75654d74e7e24881252fbff6bb9b2">More...</a><br /></td></tr>
<tr class="separator:gac6f75654d74e7e24881252fbff6bb9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432e478b97575b21855074a45d54520d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga432e478b97575b21855074a45d54520d">ucp_request_is_completed</a> (void *request)</td></tr>
<tr class="separator:ga432e478b97575b21855074a45d54520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b0a27cf8a3239decabad6a9104eb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31">ucp_put</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga85b0a27cf8a3239decabad6a9104eb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remote memory put operation.  <a href="#ga85b0a27cf8a3239decabad6a9104eb31">More...</a><br /></td></tr>
<tr class="separator:ga85b0a27cf8a3239decabad6a9104eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a465cff6c1691106430564899f6f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf4a465cff6c1691106430564899f6f3e">ucp_get</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaf4a465cff6c1691106430564899f6f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remote memory get operation.  <a href="#gaf4a465cff6c1691106430564899f6f3e">More...</a><br /></td></tr>
<tr class="separator:gaf4a465cff6c1691106430564899f6f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa042d7e76314e1d7ea9717d4adacde7b">ucp_atomic_add32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic add operation for 32 bit integers.  <a href="#gaa042d7e76314e1d7ea9717d4adacde7b">More...</a><br /></td></tr>
<tr class="separator:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa80cd3f104b920c0c2f6bf7cff50fc15">ucp_atomic_add64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic add operation for 64 bit integers.  <a href="#gaa80cd3f104b920c0c2f6bf7cff50fc15">More...</a><br /></td></tr>
<tr class="separator:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0c777d7d1c59e01151ef5e3fcd7e5b94">ucp_atomic_fadd32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic fetch and add operation for 32 bit integers.  <a href="#ga0c777d7d1c59e01151ef5e3fcd7e5b94">More...</a><br /></td></tr>
<tr class="separator:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga7435bc5d5e2c4fb6b491d457ab65596b">ucp_atomic_fadd64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic fetch and add operation for 64 bit integers.  <a href="#ga7435bc5d5e2c4fb6b491d457ab65596b">More...</a><br /></td></tr>
<tr class="separator:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43118f9d5e6d8fdfa518887218468bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga43118f9d5e6d8fdfa518887218468bb3">ucp_atomic_swap32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga43118f9d5e6d8fdfa518887218468bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic swap operation for 32 bit values.  <a href="#ga43118f9d5e6d8fdfa518887218468bb3">More...</a><br /></td></tr>
<tr class="separator:ga43118f9d5e6d8fdfa518887218468bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2913e345505195a183ccc2583fb4ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa2913e345505195a183ccc2583fb4ebc">ucp_atomic_swap64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:gaa2913e345505195a183ccc2583fb4ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic swap operation for 64 bit values.  <a href="#gaa2913e345505195a183ccc2583fb4ebc">More...</a><br /></td></tr>
<tr class="separator:gaa2913e345505195a183ccc2583fb4ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6078dddaa93c8dfdab3c18014064f0c0">ucp_atomic_cswap32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic conditional swap (cswap) operation for 32 bit values.  <a href="#ga6078dddaa93c8dfdab3c18014064f0c0">More...</a><br /></td></tr>
<tr class="separator:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gafa365c16d4c2b4fd2aba6e94fec2c92b">ucp_atomic_cswap64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic conditional swap (cswap) operation for 64 bit values.  <a href="#gafa365c16d4c2b4fd2aba6e94fec2c92b">More...</a><br /></td></tr>
<tr class="separator:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UCP Communication routines </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structucp__err__handler" id="structucp__err__handler"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structucp__err__handler">&#9670;&nbsp;</a></span>ucp_err_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_err_handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure should be initialized in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga359c847069dca9ab0d1a026dc3f5f8cd">ucp_ep_params_t</a> to handle peer failure </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0bf3f446a1821a62dd3a300584792e33"></a><a class="el" href="group___u_c_p___c_o_m_m.html#gaf2174ce2b86eb56f6bd4bd62865e87f1">ucp_err_handler_cb_t</a></td>
<td class="fieldname">
cb</td>
<td class="fielddoc">
<p>Error handler callback, if NULL, will not be called. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7e49e1843e1adab5561e5fc2b2e1afb1"></a>void *</td>
<td class="fieldname">
arg</td>
<td class="fielddoc">
<p>User defined argument associated with an endpoint, it will be overridden by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#adaf49e16ee05400f715f432e442336cb">ucp_ep_params_t::user_data</a> if both are set. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga55df42689ef1f5621eae4d1ffb16856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55df42689ef1f5621eae4d1ffb16856e">&#9670;&nbsp;</a></span>ucp_tag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP tag identifier is a 64bit object used for message identification. UCP tag send and receive operations use the object for an implementation tag matching semantics (derivative of MPI tag matching semantics). </p>

</div>
</div>
<a id="ga6a8b5741a4e66d7e890d31ef7cbf88ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8b5741a4e66d7e890d31ef7cbf88ec">&#9670;&nbsp;</a></span>ucp_tag_message_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_recv_desc* <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP Message descriptor is an opaque handle for a message returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb</a>. This handle can be passed to <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb</a> in order to receive the message data to a specific buffer. </p>

</div>
</div>
<a id="gae461587956dd56a6bc7d67b027845891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae461587956dd56a6bc7d67b027845891">&#9670;&nbsp;</a></span>ucp_datatype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP datatype identifier is a 64bit object used for datatype identification. Predefined UCP identifiers are defined by <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga50b3b4e641a197264e963d91be480b6c">ucp_dt_type</a>. </p>

</div>
</div>
<a id="gaad905bbbff95166a1e9b0e9743feb677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad905bbbff95166a1e9b0e9743feb677">&#9670;&nbsp;</a></span>ucp_send_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_send_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">send operation</a> is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed send request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee41a74074b37f96dad5b29c9af17faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee41a74074b37f96dad5b29c9af17faf">&#9670;&nbsp;</a></span>ucp_send_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_send_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">send operation</a> is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed send request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a41">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaf2174ce2b86eb56f6bd4bd62865e87f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2174ce2b86eb56f6bd4bd62865e87f1">&#9670;&nbsp;</a></span>ucp_err_handler_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_err_handler_cb_t) (void *arg, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked when transport level error detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint to handle transport level error. Upon return from the callback, this <em>ep</em> is no longer usable and all subsequent operations on this <em>ep</em> will fail with the error code passed in <em>status</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga487a20aada512b312bc21757e368120d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487a20aada512b312bc21757e368120d">&#9670;&nbsp;</a></span>ucp_err_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a>  <a class="el" href="group___u_c_p___c_o_m_m.html#ga487a20aada512b312bc21757e368120d">ucp_err_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure should be initialized in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga359c847069dca9ab0d1a026dc3f5f8cd">ucp_ep_params_t</a> to handle peer failure </p>

</div>
</div>
<a id="ga6a6234b8497006e26ba02f10ddc0bbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6234b8497006e26ba02f10ddc0bbf5">&#9670;&nbsp;</a></span>ucp_stream_recv_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_stream_recv_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9e253400533137ba2a5a49a111a9ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e253400533137ba2a5a49a111a9ee8">&#9670;&nbsp;</a></span>ucp_stream_recv_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_stream_recv_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#ga30494ce33e63823c81c2c5b3656d25c3">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always on the boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00ac0fe5665d15fab5cd254af9b07758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00ac0fe5665d15fab5cd254af9b07758">&#9670;&nbsp;</a></span>ucp_tag_recv_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_tag_recv_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. If the data can not fit into the receive buffer the <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558aef3defd5d754266db882e079fad7c544">UCS_ERR_MESSAGE_TRUNCATED</a> error code is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">Completion information</a> The <em>info</em> descriptor is Valid only if the status is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70e110cf7c85ed5f281bd52438488d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e110cf7c85ed5f281bd52438488d75">&#9670;&nbsp;</a></span>ucp_tag_recv_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_tag_recv_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *tag_info, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the receive operation was completed successfully UCS_OK is returned. If send operation was canceled, UCS_ERR_CANCELED is returned. If the data can not fit into the receive buffer the <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558aef3defd5d754266db882e079fad7c544">UCS_ERR_MESSAGE_TRUNCATED</a> error code is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">Completion information</a> The <em>info</em> descriptor is Valid only if the status is UCS_OK. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga242399982563973351591516039dd74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242399982563973351591516039dd74b">&#9670;&nbsp;</a></span>ucp_am_recv_data_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_am_recv_data_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaefaaa5e0a154efe496ae5bb7f2bf71f3">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the receive operation was completed successfully UCS_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac5d94ea07dc4feae2708e67378ba2ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d94ea07dc4feae2708e67378ba2ad0">&#9670;&nbsp;</a></span>ucp_atomic_post_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines which atomic memory operation should be performed by the ucp_atomic_post family of fuctions. All of these are non-fetching atomics and will not result in a request handle. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0"></a>UCP_ATOMIC_POST_OP_ADD&#160;</td><td class="fielddoc"><p>Atomic add </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4"></a>UCP_ATOMIC_POST_OP_AND&#160;</td><td class="fielddoc"><p>Atomic and </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460"></a>UCP_ATOMIC_POST_OP_OR&#160;</td><td class="fielddoc"><p>Atomic or </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89"></a>UCP_ATOMIC_POST_OP_XOR&#160;</td><td class="fielddoc"><p>Atomic xor </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d"></a>UCP_ATOMIC_POST_OP_LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gabd91e0300a53e38d28dbb53dfbb66c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd91e0300a53e38d28dbb53dfbb66c55">&#9670;&nbsp;</a></span>ucp_atomic_fetch_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines which atomic memory operation should be performed by the ucp_atomic_fetch family of functions. All of these functions will fetch data from the remote node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037"></a>UCP_ATOMIC_FETCH_OP_FADD&#160;</td><td class="fielddoc"><p>Atomic Fetch and add </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069"></a>UCP_ATOMIC_FETCH_OP_SWAP&#160;</td><td class="fielddoc"><p>Atomic swap </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c"></a>UCP_ATOMIC_FETCH_OP_CSWAP&#160;</td><td class="fielddoc"><p>Atomic conditional swap </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3"></a>UCP_ATOMIC_FETCH_OP_FAND&#160;</td><td class="fielddoc"><p>Atomic Fetch and and </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59"></a>UCP_ATOMIC_FETCH_OP_FOR&#160;</td><td class="fielddoc"><p>Atomic Fetch and or </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049"></a>UCP_ATOMIC_FETCH_OP_FXOR&#160;</td><td class="fielddoc"><p>Atomic Fetch and xor </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05"></a>UCP_ATOMIC_FETCH_OP_LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga5c2ee7516e48146c044e3d9e2a2ed380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c2ee7516e48146c044e3d9e2a2ed380">&#9670;&nbsp;</a></span>ucp_atomic_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines which atomic memory operation should be performed by the <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> routine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b"></a>UCP_ATOMIC_OP_ADD&#160;</td><td class="fielddoc"><p>Atomic add </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb"></a>UCP_ATOMIC_OP_SWAP&#160;</td><td class="fielddoc"><p>Atomic swap </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a"></a>UCP_ATOMIC_OP_CSWAP&#160;</td><td class="fielddoc"><p>Atomic conditional swap </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3"></a>UCP_ATOMIC_OP_AND&#160;</td><td class="fielddoc"><p>Atomic and </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e"></a>UCP_ATOMIC_OP_OR&#160;</td><td class="fielddoc"><p>Atomic or </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243"></a>UCP_ATOMIC_OP_XOR&#160;</td><td class="fielddoc"><p>Atomic xor </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380a0983496b62f2d28cf043966793c6bb0b"></a>UCP_ATOMIC_OP_LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gab471a9c7ab815e3d3ad7af80253f5cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab471a9c7ab815e3d3ad7af80253f5cc2">&#9670;&nbsp;</a></span>ucp_stream_recv_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines behavior of <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c"></a>UCP_STREAM_RECV_FLAG_WAITALL&#160;</td><td class="fielddoc"><p>This flag requests that the operation will not be completed until all requested data is received and placed in the user buffer. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga67fae646dd1668efba6efe49a35a6610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67fae646dd1668efba6efe49a35a6610">&#9670;&nbsp;</a></span>ucp_op_attr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> are present and operation flags are used. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996"></a>UCP_OP_ATTR_FIELD_REQUEST&#160;</td><td class="fielddoc"><p>request field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602"></a>UCP_OP_ATTR_FIELD_CALLBACK&#160;</td><td class="fielddoc"><p>cb field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610af6f932f15331fe7c9efacbfe2578e5ec"></a>UCP_OP_ATTR_FIELD_USER_DATA&#160;</td><td class="fielddoc"><p>user_data field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a354ef92dd9352dfccc859cd2ca3558d8"></a>UCP_OP_ATTR_FIELD_DATATYPE&#160;</td><td class="fielddoc"><p>datatype field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a2f2586686e21b2700fd7cd4a8efb5a1b"></a>UCP_OP_ATTR_FIELD_FLAGS&#160;</td><td class="fielddoc"><p>operation-specific flags </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0"></a>UCP_OP_ATTR_FIELD_REPLY_BUFFER&#160;</td><td class="fielddoc"><p>reply_buffer field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a768b4c6759502c34b0051ba33c0d05b3"></a>UCP_OP_ATTR_FIELD_MEMORY_TYPE&#160;</td><td class="fielddoc"><p>memory type field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610ac5a4c17a81a2efefae5e338479ae06cb"></a>UCP_OP_ATTR_FIELD_RECV_INFO&#160;</td><td class="fielddoc"><p>recv_info field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a8805045d48573e9aa5751b439be114d0"></a>UCP_OP_ATTR_FLAG_NO_IMM_CMPL&#160;</td><td class="fielddoc"><p>deny immediate completion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a69a2066ee5f68e57021f622b0cc859a8"></a>UCP_OP_ATTR_FLAG_FAST_CMPL&#160;</td><td class="fielddoc"><p>expedite local completion, even if it delays remote data delivery. Note for implementer: this option can disable zero copy and/or rendezvous protocols which require synchronization with the remote peer before releasing the local send buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610aeb35a090d86119cfd25d4e82753e943f"></a>UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL&#160;</td><td class="fielddoc"><p>force immediate complete operation, fail if the operation cannot be completed immediately </p>
</td></tr>
</table>

</div>
</div>
<a id="ga487a3c588a11e42b9f313f0c9e2ead3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487a3c588a11e42b9f313f0c9e2ead3b">&#9670;&nbsp;</a></span>ucp_am_recv_attr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#ga487a3c588a11e42b9f313f0c9e2ead3b">ucp_am_recv_attr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga435d870d0afb413f0bc780809f1db2ef">ucp_am_recv_param_t</a> are present and receive operation flags are used. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga487a3c588a11e42b9f313f0c9e2ead3ba7a4057be7a4cc3bba470da4f8ed63259"></a>UCP_AM_RECV_ATTR_FIELD_REPLY_EP&#160;</td><td class="fielddoc"><p>reply_ep field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga487a3c588a11e42b9f313f0c9e2ead3baf77ecce2987e81bf773a48363767b77e"></a>UCP_AM_RECV_ATTR_FLAG_DATA&#160;</td><td class="fielddoc"><p>Indicates that the data provided in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a> callback can be held by the user. If UCS_INPROGRESS is returned from the callback, the data parameter will persist and the user has to call <a class="el" href="group___u_c_p___c_o_m_m.html#ga45570903fc3ce01e7e5c0cd241f516f9">ucp_am_data_release</a> when data is no longer needed. This flag is mutually exclusive with <em>UCP_AM_RECV_ATTR_FLAG_RNDV</em>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga487a3c588a11e42b9f313f0c9e2ead3baf9a8d75af5b826d7563863591a98714f"></a>UCP_AM_RECV_ATTR_FLAG_RNDV&#160;</td><td class="fielddoc"><p>Indicates that the arriving data was sent using rendezvous protocol. In this case <em>data</em> parameter of the <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a> points to the internal UCP descriptor, which can be used for obtaining the actual data by calling <a class="el" href="group___u_c_p___c_o_m_m.html#gaefaaa5e0a154efe496ae5bb7f2bf71f3">ucp_am_recv_data_nbx</a> routine. This flag is mutually exclusive with <em>UCP_AM_RECV_ATTR_FLAG_DATA</em>. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaeae021145933ffa033b8327bb7bf2533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeae021145933ffa033b8327bb7bf2533">&#9670;&nbsp;</a></span>ucp_am_handler_param_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gaeae021145933ffa033b8327bb7bf2533">ucp_am_handler_param_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga41064b7ada287b9a2138451ef63ea1e4">ucp_am_handler_param_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a4b9788659b793630cee9bc027add35ad"></a>UCP_AM_HANDLER_PARAM_FIELD_ID&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ad0c6157f387e18cb4d92a37a638274af">ucp_am_handler_param_t::id</a> field is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a99854985610ec532f0c83e36b3cadb3d"></a>UCP_AM_HANDLER_PARAM_FIELD_FLAGS&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#a061115b2dc01fb803ae8082bd41f8730">ucp_am_handler_param_t::flags</a> field is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a6c2a2d3fe9c7118d3513833ad452cb69"></a>UCP_AM_HANDLER_PARAM_FIELD_CB&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#acd54cdefba3f3f5e145dfe2360485659">ucp_am_handler_param_t::cb</a> field is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a23622f1a9046a0b59d1519732e2b73ff"></a>UCP_AM_HANDLER_PARAM_FIELD_ARG&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ae1670a4926d8528fb1ec1cd3f461f13a">ucp_am_handler_param_t::arg</a> field is valid. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga94ec21811930b6b6fb8eab500b8c730d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ec21811930b6b6fb8eab500b8c730d">&#9670;&nbsp;</a></span>ucp_am_send_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_am_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends an Active Message to an ep. It does not support CUDA memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint where the Active Message will be run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Active Message id. Specifies which registered callback to run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the data to be sent to the target node of the Active Message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback that is invoked upon completion of the data transfer if it is not completed immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Operation flags as defined by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga583228e89cd5c882025ed04c76106aa6">ucp_send_am_flags</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Active Message was sent immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) Error sending Active Message. </dd>
<dd>
otherwise Pointer to request, and Active Message is known to be completed after cb is run. </dd></dl>

</div>
</div>
<a id="ga4b8ab214f35828ee4608d73442e8c372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8ab214f35828ee4608d73442e8c372">&#9670;&nbsp;</a></span>ucp_am_send_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_am_send_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends an Active Message to an ep. If the operation completes immediately, then the routine returns NULL and the callback function is ignored, even if specified. Otherwise, if no error is reported and a callback is requested (i.e. the UCP_OP_ATTR_FIELD_CALLBACK flag is set in the op_attr_mask field of <em>param</em>), then the UCP library will schedule invocation of the callback routine <em>param-&gt;cb.send</em> upon completion of the operation.</p>
<dl class="section note"><dt>Note</dt><dd>If UCP_OP_ATTR_FLAG_NO_IMM_CMPL flag is set in the op_attr_mask field of <em>param</em>, then the operation will return a request handle, even if it completes immediately. </dd>
<dd>
Currently Active Message API supports communication operations with host memory only. </dd>
<dd>
This operation supports specific flags, which can be passed in <em>param</em> by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a55a8ff2559470c5def6077a86ee9d898">ucp_request_param_t::flags</a>. The exact set of flags is defined by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga583228e89cd5c882025ed04c76106aa6">ucp_send_am_flags</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint where the Active Message will be run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Active Message id. Specifies which registered callback to run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>User defined Active Message header. NULL value is allowed if no header needed. In this case <em>header_length</em> should be set to 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header_length</td><td>Active message header length in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the data to be sent to the target node of the Active Message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending only header without actual data is allowed and is recommended for transfering latency-critical amount of data. </dd>
<dd>
The maximum allowed header size can be obtained by querying worker attributes by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query</a> routine.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - Active Message was sent immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - Error sending Active Message. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed at any point in time. The request handle is returned to the application in order to track progress of the message. If user request was not provided in <em>param-&gt;request</em>, the application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a42">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaefaaa5e0a154efe496ae5bb7f2bf71f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefaaa5e0a154efe496ae5bb7f2bf71f3">&#9670;&nbsp;</a></span>ucp_am_recv_data_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_am_recv_data_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the data descriptor <em>data_desc</em>, local address <em>buffer</em>, size <em>count</em> and <em>param</em> parameters on the <em>worker</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. If the receive operation cannot be started the routine returns an error.</p>
<dl class="section note"><dt>Note</dt><dd>After this call UCP takes ownership of <em>data_desc</em> descriptor, so there is no need to release it even if the operation fails. The routine returns a request handle instead, which can further be used for tracking operation progress.</dd>
<dd>
Currently Active Message API supports communication operations with host memory only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_desc</td><td>Data descriptor, provided in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a> routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. In this case, if <em>param-&gt;recv_info.length</em> is specified in the <em>param</em>, the value to which it points is updated with the size of the received message. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Receive operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track operation progress. If user request was not provided in <em>param-&gt;request</em>, the application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a40">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga45570903fc3ce01e7e5c0cd241f516f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45570903fc3ce01e7e5c0cd241f516f9">&#9670;&nbsp;</a></span>ucp_am_data_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_am_data_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine releases data that persisted through an Active Message callback because that callback returned UCS_INPROGRESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker which received the Active Message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to data that was passed into the Active Message callback as the data parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9022ff0ebb56cac81f6ba81bb28f71b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9022ff0ebb56cac81f6ba81bb28f71b3">&#9670;&nbsp;</a></span>ucp_stream_send_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends data that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK and the callback function <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported, then the UCP library will schedule invocation of the callback <em>cb</em> upon completion of the send operation. In other words, the completion of the operation will be signaled either by the return code or by the callback.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed. It is important to note that the callback is only invoked in the event that the operation cannot be completed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Reserved for future use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>

</div>
</div>
<a id="gae9fe6efe6b05e4e78f58bee68c68b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9fe6efe6b05e4e78f58bee68c68b252">&#9670;&nbsp;</a></span>ucp_stream_send_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_send_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends data that is described by the local address <em>buffer</em>, size <em>count</em> object to the destination endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed at any point in time. The request handle is returned to the application in order to track progress of the message. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a28">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaae7343bd638924e5518041311d5c1dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7343bd638924e5518041311d5c1dfc">&#9670;&nbsp;</a></span>ucp_tag_send_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">receiver</a>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine return UCS_OK and the call-back function <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported then the UCP library will schedule to invoke the call-back <em>cb</em> whenever the send operation will be completed. In other words, the completion of a message can be signaled by the return code or the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="gad90aa964e14fef59b4e3bd9120cca669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad90aa964e14fef59b4e3bd9120cca669">&#9670;&nbsp;</a></span>ucp_tag_send_nbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_send_nbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine provides a convenient and efficient way to implement a blocking send pattern. It also completes requests faster than <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb()</a> because: </p><ul>
<li>it always uses <a class="el" href="group___u_c_t___a_m.html#gae29dad6b69beaf21c19255906742e14d">uct_ep_am_bcopy()</a> to send data up to the rendezvous threshold. </li>
<li>its rendezvous threshold is higher than the one used by the <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb()</a>. The threshold is controlled by the <b>UCX_SEND_NBR_RNDV_THRESH</b> environment variable. </li>
<li>its request handling is simpler. There is no callback and no need to allocate and free requests. In fact request can be allocated by caller on the stack.</li>
</ul>
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">receiver</a>.</p>
<p>The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK.</p>
<p>If the operation is <b>not</b> completed immediately and no error reported then the UCP library will fill a user provided <em>req</em> and return UCS_INPROGRESS status. In order to monitor completion of the operation <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status()</a> should be used.</p>
<p>Following pseudo code implements a blocking send function: </p><div class="fragment"><div class="line">MPI_send(...)</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span> *request;</div><div class="line">    <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">// allocate request on the stack</span></div><div class="line">    <span class="comment">// ucp_context_query() was used to get ucp_request_size</span></div><div class="line">    request = alloca(ucp_request_size);</div><div class="line"></div><div class="line">    <span class="comment">// note: make sure that there is enough memory before the</span></div><div class="line">    <span class="comment">// request handle</span></div><div class="line">    status = <a class="code" href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr</a>(ep, ..., request + ucp_request_size);</div><div class="line">    <span class="keywordflow">if</span> (status != <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a>) {</div><div class="line">        <span class="keywordflow">return</span> status;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">        <a class="code" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a>(worker);</div><div class="line">        status = <a class="code" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a>(request + ucp_request_size);</div><div class="line">    } <span class="keywordflow">while</span> (status == <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> status;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle allocated by the user. There should be at least UCP request size bytes of available space before the <em>req</em>. The size of UCP request can be obtained by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga3485fb61663f4cc6f32e801654aedcff">ucp_context_query</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_INPROGRESS - The send was not completed and is in progress. <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status()</a> should be used to monitor <em>req</em> status. </dd>
<dd>
Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gabd3e1ccae2ef34463e8313d09d3db17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd3e1ccae2ef34463e8313d09d3db17f">&#9670;&nbsp;</a></span>ucp_tag_send_sync_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_sync_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb</a>, except the request completes only after there is a remote tag match on the message (which does not always mean the remote receive has been completed). This function never completes "in-place", and always returns a request handle.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes. </dd>
<dd>
Returns <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a252c38290855ceaf849c04b7fa52dc23">UCS_ERR_UNSUPPORTED</a> if <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gga7c69a28724d5ae3e49490e23e64df167aa31630259732e700b6ce0fe612cf0a6f">UCP_ERR_HANDLING_MODE_PEER</a> is enabled. This is a temporary implementation-related constraint that will be addressed in future releases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga8323878b60f426c630d4ff8996ede3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8323878b60f426c630d4ff8996ede3cc">&#9670;&nbsp;</a></span>ucp_tag_send_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">receiver</a>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK and the call-back function is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported then the UCP library will schedule to invoke the call-back whenever the send operation is completed. In other words, the completion of a message can be signaled by the return code or the call-back. Immediate completion signals can be fine-tuned via the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a97e9444548efb351db6a07130fb69c28">ucp_request_param_t::op_attr_mask</a> field in the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> structure. The values of this field are a bit-wise OR of the <a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a> enumeration.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a33">ucp_client_server.c</a>, and <a class="el" href="ucp_hello_world_8c-example.html#a29">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga0d96a2aac42fe99ce0c79f15dda8bd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d96a2aac42fe99ce0c79f15dda8bd06">&#9670;&nbsp;</a></span>ucp_tag_send_sync_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_sync_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a>, except the request completes only after there is a remote tag match on the message (which does not always mean the remote receive has been completed). This function never completes "in-place", and always returns a request handle.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes. </dd>
<dd>
Returns <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a252c38290855ceaf849c04b7fa52dc23">UCS_ERR_UNSUPPORTED</a> if <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gga7c69a28724d5ae3e49490e23e64df167aa31630259732e700b6ce0fe612cf0a6f">UCP_ERR_HANDLING_MODE_PEER</a> is enabled. This is a temporary implementation-related constraint that will be addressed in future releases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. </dd></dl>

</div>
</div>
<a id="gadf3b4504a329a46d2d4ec0a8cec08130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3b4504a329a46d2d4ec0a8cec08130">&#9670;&nbsp;</a></span>ucp_stream_recv_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives data that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered complete when the message is delivered to the buffer. If data is not immediately available, the operation will be scheduled for receive and a request handle will be returned. In order to notify the application about completion of a scheduled receive operation, the UCP library will invoke the call-back <em>cb</em> when data is in the receive buffer and ready for application access. If the receive operation cannot be started, the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>. It is important to note that the call-back is only invoked in a case when the operation cannot be completed immediately. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Size of the received data in bytes. The value is valid only if return code is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The amount of data received, in bytes, is always an integral multiple of the <em>datatype</em> size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags defined in <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. A request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>

</div>
</div>
<a id="ga30494ce33e63823c81c2c5b3656d25c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30494ce33e63823c81c2c5b3656d25c3">&#9670;&nbsp;</a></span>ucp_stream_recv_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives data that is described by the local address <em>buffer</em>, size <em>count</em> object on the endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered complete when the message is delivered to the buffer. If the receive operation cannot be started, the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer that will receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Size of the received data in bytes. The value is valid only if return code is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>. This operation supports specific flags, which can be passed in <em>param</em> by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a55a8ff2559470c5def6077a86ee9d898">ucp_request_param_t::flags</a>. The exact set of flags is defined by <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. In this case the value pointed by <em>length</em> is updated by the size of received data. Note <em>param-&gt;recv_info</em> is not relevant for this function. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. A request handle is returned to the application in order to track progress of the operation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The amount of data received, in bytes, is always an integral multiple of the <em>datatype</em> size. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a32">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga47f307f4765eb5410f24ac27986b59d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f307f4765eb5410f24ac27986b59d7">&#9670;&nbsp;</a></span>ucp_stream_recv_data_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_data_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives any available data from endpoint <em>ep</em>. Unlike <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a>, the returned data is unstructured and is treated as an array of bytes. If data is immediately available, UCS_STATUS_PTR(_ptr) is returned as a pointer to the data, and <em>length</em> is set to the size of the returned data buffer. The routine is non-blocking and therefore returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Length of received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - No received data available on the <em>ep</em>. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - the receive operation failed and UCS_PTR_STATUS(_ptr) indicates an error. </dd>
<dd>
otherwise - The pointer to the data UCS_STATUS_PTR(_ptr) is returned to the application. After the data is processed, the application is responsible for releasing the data buffer by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga1d1c1c1b2caf4f26c9872e1d708d5f68">ucp_stream_data_release</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns packed data (equivalent to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a>). </dd>
<dd>
This function returns a pointer to a UCP-supplied buffer, whereas <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> places the data into a user-provided buffer. In some cases, receiving data directly into a UCP-supplied buffer can be more optimal, for example by processing the incoming data in-place and thus avoiding extra memory copy operations. </dd></dl>

</div>
</div>
<a id="gaeb24cdfc33dfb2886551b51843aa6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb24cdfc33dfb2886551b51843aa6304">&#9670;&nbsp;</a></span>ucp_tag_recv_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates which bits of the tag have to be matched. The routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be stated the routine returns an error.</p>
<dl class="section note"><dt>Note</dt><dd>This routine cannot return UCS_OK. It always returns a request handle or an error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga5a86663a4a144fd81d7a4e3378c5edd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a86663a4a144fd81d7a4e3378c5edd2">&#9670;&nbsp;</a></span>ucp_tag_recv_nbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_recv_nbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates which bits of the tag have to be matched. The routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to monitor completion of the operation <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#ga707cbbef8cdcf90fa7cf63c922ef2c7f">ucp_tag_recv_request_test</a> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle allocated by the user. There should be at least UCP request size bytes of available space before the <em>req</em>. The size of UCP request can be obtained by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga3485fb61663f4cc6f32e801654aedcff">ucp_context_query</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa842f8ca8ad1363ed857ab938285a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa842f8ca8ad1363ed857ab938285a16f">&#9670;&nbsp;</a></span>ucp_tag_recv_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_recv_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>info</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The routine is a non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be stated the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. In this case, if <em>param-&gt;recv_info.tag_info</em> is specified in the <em>param</em>, the value to which it points is updated with the information about the received message. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a34">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga41668f468dc37a7634116b8210815f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41668f468dc37a7634116b8210815f22">&#9670;&nbsp;</a></span>ucp_tag_probe_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> ucp_tag_probe_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine probes (checks) if a messages described by the <em>tag</em> and <em>tag_mask</em> was received (fully or partially) on the <em>worker</em>. The tag value of the received message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The function returns immediately and if the message is matched it returns a handle for the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the probe operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to probe for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove</td><td>The flag indicates if the matched message has to be removed from UCP library. If true (1), the message handle is removed from the UCP library and the application is responsible to call <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a> in order to receive the data and release the resources associated with the message handle. If false (0), the return value is merely an indication to whether a matching message is present, and it cannot be used in any other way, and in particular it cannot be passed to <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>If the matching message is found the descriptor is filled with the details about the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - No match found. </dd>
<dd>
Message handle (not NULL) - If message is matched the message handle is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not advance the communication state of the network. If this routine is used in busy-poll mode, need to make sure <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress()</a> is called periodically to extract messages from the transport. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a30">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="gac335b3ae4c9577728d9c0f2ecd44c084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac335b3ae4c9577728d9c0f2ecd44c084">&#9670;&nbsp;</a></span>ucp_tag_msg_recv_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_msg_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, <em>message</em> handle, and <em>datatype</em> object on the <em>worker</em>. The <em>message</em> handle can be obtained by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb()</a> routine. The <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a> routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be started the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer that will receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a32">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga48c61d44f18362bdaf8fca3122efcea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c61d44f18362bdaf8fca3122efcea6">&#9670;&nbsp;</a></span>ucp_tag_msg_recv_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_msg_recv_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>message</em> handle on the <em>worker</em>. The <em>message</em> handle can be obtained by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb()</a> routine. The <a class="el" href="group___u_c_p___c_o_m_m.html#ga48c61d44f18362bdaf8fca3122efcea6">ucp_tag_msg_recv_nbx()</a> routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be started the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer that will receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga77f3d5def7a77c4ba88f9e1eefa4b7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">&#9670;&nbsp;</a></span>ucp_put_nbi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_put_nbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" <em>rkey</em>. The routine returns immediately and <b>does</b> <b>not</b> guarantee re-usability of the source address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga1ba986b2bde69c215abd5766dbceeb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba986b2bde69c215abd5766dbceeb18">&#9670;&nbsp;</a></span>ucp_put_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_put_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" <em>rkey</em>. The routine returns immediately and <b>does</b> <b>not</b> guarantee re-usability of the source address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the put operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the put operation. In other words, the completion of a put operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the put operation is completed and the local buffer can be modified. Does not guarantee remote completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga29e7b9b70b782140e63544b8613a5fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e7b9b70b782140e63544b8613a5fe7">&#9670;&nbsp;</a></span>ucp_put_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_put_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" <em>rkey</em>. The routine returns immediately and <b>does</b> <b>not</b> guarantee re-usability of the source address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the put operation completes immediately, the routine returns UCS_OK and the call-back routine <em>param.cb.send</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>param.cb.send</em> upon completion of the put operation. In other words, the completion of a put operation can be signaled by the return code or execution of the call-back. Immediate completion signals can be fine-tuned via the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a97e9444548efb351db6a07130fb69c28">ucp_request_param_t::op_attr_mask</a> field in the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> structure. The values of this field are a bit-wise OR of the <a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a> enumeration.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements of type <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> to put. If <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> is not specified, the type defaults to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a>, which corresponds to byte elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only the datatype <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a> is supported for <em>param-&gt;datatype</em>, see <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5">ucp_dt_make_contig</a>. </dd></dl>

</div>
</div>
<a id="gae3597f699227d598651f6630fbd7968b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3597f699227d598651f6630fbd7968b">&#9670;&nbsp;</a></span>ucp_get_nbi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_get_nbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiate a load of contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order guarantee that remote data is loaded and stored under the local address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the source remote memory address to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga7cb68811f53a69d37fd16e8ddb46e23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb68811f53a69d37fd16e8ddb46e23b">&#9670;&nbsp;</a></span>ucp_get_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_get_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a load of a contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the get operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the get operation. In other words, the completion of a get operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the source remote memory address to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the get operation is completed and the data is visible to the local process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="gaa06c6521592661a8123c11426074d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa06c6521592661a8123c11426074d880">&#9670;&nbsp;</a></span>ucp_get_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_get_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a load of a contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the get operation completes immediately, the routine returns UCS_OK and the call-back routine <em>param.cb.send</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>param.cb.send</em> upon completion of the get operation. In other words, the completion of a get operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements of type <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> to put. If <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> is not specified, the type defaults to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a>, which corresponds to byte elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the source remote memory address to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only the datatype <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a> is supported for <em>param-&gt;datatype</em>, see <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5">ucp_dt_make_contig</a>. </dd></dl>

</div>
</div>
<a id="ga839312fb4de5e786daacb4fa071d61df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839312fb4de5e786daacb4fa071d61df">&#9670;&nbsp;</a></span>ucp_atomic_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine posts an atomic memory operation to a remote value. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. Return from the function does not guarantee completion. A user must call <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga599c9b9272bfdd662afaa247d8e4dfd6">ucp_ep_flush_nb</a> or <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb</a> to guarantee that the remote value has been updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source operand for the atomic operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_size</td><td>Size of value in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga43a1a4a517797eb8c5c96ac8841437de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43a1a4a517797eb8c5c96ac8841437de">&#9670;&nbsp;</a></span>ucp_atomic_fetch_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_atomic_fetch_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine will post an atomic fetch operation to remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The routine is non-blocking and therefore returns immediately. However the actual atomic operation may be delayed. The atomic operation is not considered complete until the values in remote and local memory are completed. If the atomic operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the atomic operation. In other words, the completion of an atomic operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>result</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source operand for atomic operation. In the case of CSWAP this is the conditional for the swap. For SWAP this is the value to be placed in remote memory. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>Local memory address to store resulting fetch to. In the case of CSWAP the value in result will be swapped into the <em>remote_addr</em> if the condition is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_size</td><td>Size of value in bytes and pointer type for result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the send operation is completed. It is important to note that the call-back function is only invoked in a case when the operation cannot be completed in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga087e2cad02e84cf1230684362562aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga087e2cad02e84cf1230684362562aa46">&#9670;&nbsp;</a></span>ucp_atomic_op_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_atomic_op_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine will post an atomic operation to remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The routine is non-blocking and therefore returns immediately. However, the actual atomic operation may be delayed. In order to enable fetching semantics for atomic operations user has to specify <em>param.reply_buffer</em>. Please see <a class="el" href="group___u_c_p___c_o_m_m.html#atomic_ops">table</a> below for more details.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> (or also <em>param-&gt;reply_buffer</em> for fetch operations), until the operation completes. </dd>
<dd>
Only ucp_dt_make_config(4) and <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(8)</a> are supported in <em>param-&gt;datatype</em>, see <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5">ucp_dt_make_contig</a>. Also, currently atomic operations can handle one element only. Thus, <em>count</em> argument must be set to 1.</dd></dl>
<a class="anchor" id="atomic_ops"></a>
<table class="doxtable">
<caption>Atomic Operations Semantic</caption>
<tr>
<th align="center">Atomic Operation </th><th align="center">Pseudo code </th><th align="center">X </th><th align="center">Y </th><th align="center">Z </th><th align="center">Result </th></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b">UCP_ATOMIC_OP_ADD</a> </td><td align="left">Result=Y; Y+=X </td><td align="left">buffer</td><td align="left">remote_addr</td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb">UCP_ATOMIC_OP_SWAP</a> </td><td align="left">Result=Y; Y=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a">UCP_ATOMIC_OP_CSWAP</a> </td><td align="left">Result=Y; if (X==Y) then Y=Z</td><td align="left">buffer </td><td align="left">remote_addr </td><td align="left">param.reply_buffer </td><td align="left">param.reply_buffer </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3">UCP_ATOMIC_OP_AND</a> </td><td align="left">Result=Y; Y&amp;=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e">UCP_ATOMIC_OP_OR</a> </td><td align="left">Result=Y; Y|=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243">UCP_ATOMIC_OP_XOR</a> </td><td align="left">Result=Y; Y^=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Address of operand for the atomic operation. See <a class="el" href="group___u_c_p___c_o_m_m.html#atomic_ops">Atomic Operations Semantic table</a> for exact usage by different atomic operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements in <em>buffer</em> and <em>result</em>. The size of each element is specified by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at some time in the future. The request handle is returned to the application in order to track progress of the operation. </dd></dl>

</div>
</div>
<a id="gae082ad7af428645ebe6e469d3d06a757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae082ad7af428645ebe6e469d3d06a757">&#9670;&nbsp;</a></span>ucp_request_check_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_request_check_status </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state of the request and returns its current status. Any value different from UCS_INPROGRESS means that request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a20">ucp_client_server.c</a>, and <a class="el" href="ucp_hello_world_8c-example.html#a4">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga707cbbef8cdcf90fa7cf63c922ef2c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707cbbef8cdcf90fa7cf63c922ef2c7f">&#9670;&nbsp;</a></span>ucp_tag_recv_request_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_recv_request_test </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state and returns current status of the request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> routine or the user allocated request for <a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">ucp_tag_recv_nbr</a>. Any value different from UCS_INPROGRESS means that the request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>It is filled with the details about the message available at the moment of calling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga4d8d8823b24cb25dcab8bf44c72fa25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8d8823b24cb25dcab8bf44c72fa25e">&#9670;&nbsp;</a></span>ucp_stream_recv_request_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_stream_recv_request_test </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state and returns current status of the request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> routine. Any value different from UCS_INPROGRESS means that the request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length_p</td><td>The size of the received data in bytes. This value is only valid if the status is UCS_OK. If valid, it is always an integral multiple of the datatype size associated with the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga3553f89a61d6b40af4633a2e7c84fc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3553f89a61d6b40af4633a2e7c84fc1d">&#9670;&nbsp;</a></span>ucp_request_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_request_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to cancel.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine tries to cancels an outstanding communication request. After calling this routine, the <em>request</em> will be in completed or canceled (but not both) state regardless of the status of the target endpoint associated with the communication request. If the request is completed successfully, the <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">send</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">receive</a> completion callbacks (based on the type of the request) will be called with the <em>status</em> argument of the callback set to UCS_OK, and in a case it is canceled the <em>status</em> argument is set to UCS_ERR_CANCELED. It is important to note that in order to release the request back to the library the application is responsible for calling <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a>. </p>

</div>
</div>
<a id="ga1d1c1c1b2caf4f26c9872e1d708d5f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d1c1c1b2caf4f26c9872e1d708d5f68">&#9670;&nbsp;</a></span>ucp_stream_data_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_stream_data_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint <em>data</em> received from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data pointer to release, which was returned from <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases internal UCP data buffer returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a> when <em>data</em> is processed, the application can't use this buffer after calling this function. </p>

</div>
</div>
<a id="ga0e8e46f5953d464382b21edef3ec9994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8e46f5953d464382b21edef3ec9994">&#9670;&nbsp;</a></span>ucp_request_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_request_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases the non-blocking request back to the library, regardless of its current state. Communications operations associated with this request will make progress internally, however no further notifications or callbacks will be invoked for this request. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a21">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="gac6f75654d74e7e24881252fbff6bb9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f75654d74e7e24881252fbff6bb9b2">&#9670;&nbsp;</a></span>ucp_request_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ucp_request_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a></dd></dl>
<p>This routine creates request which may be used in functions <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a>, etc. The application is responsible for releasing the handle using the <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine </p>

</div>
</div>
<a id="ga432e478b97575b21855074a45d54520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432e478b97575b21855074a45d54520d">&#9670;&nbsp;</a></span>ucp_request_is_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ucp_request_is_completed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga3802a983138ed27034b7d52026dccb2f">ucp_request_test</a>. </dd></dl>

</div>
</div>
<a id="ga85b0a27cf8a3239decabad6a9104eb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85b0a27cf8a3239decabad6a9104eb31">&#9670;&nbsp;</a></span>ucp_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a>. The following example implements the same functionality using <a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a> : </dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> empty_callback(<span class="keywordtype">void</span> *request, <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> put(<a class="code" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <span class="keyword">const</span> <span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> length,</div><div class="line">                  uint64_t remote_addr, <a class="code" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> *request = <a class="code" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a>(ep, buffer, length, remote_addr, rkey,</div><div class="line">                               empty_callback),</div><div class="line">    <span class="keywordflow">if</span> (request == NULL) {</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a">UCS_OK</a>;</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (UCS_PTR_IS_ERR(request)) {</div><div class="line">        <span class="keywordflow">return</span> UCS_PTR_STATUS(request);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status;</div><div class="line">        <span class="keywordflow">do</span> {</div><div class="line">            <a class="code" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a>(worker);</div><div class="line">            status = <a class="code" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a>(request);</div><div class="line">        } <span class="keywordflow">while</span> (status == <a class="code" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a>);</div><div class="line">        <a class="code" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gaabf569a298946627fbc8d66814c35e68">ucp_request_release</a>(request);</div><div class="line">        <span class="keywordflow">return</span> status;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This routine stores contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em>. The routine returns when it is safe to reuse the source address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaf4a465cff6c1691106430564899f6f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a465cff6c1691106430564899f6f3e">&#9670;&nbsp;</a></span>ucp_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga7cb68811f53a69d37fd16e8ddb46e23b">ucp_get_nb</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine loads contiguous block of data that is described by the remote address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns when remote data is loaded and stored under the local address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa042d7e76314e1d7ea9717d4adacde7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa042d7e76314e1d7ea9717d4adacde7b">&#9670;&nbsp;</a></span>ucp_atomic_add32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_add32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> with opcode UCP_ATOMIC_POST_OP_ADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 32 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes the sum of the original remote value and the operand value (<em>add</em>) is stored in remote memory. The call to the routine returns immediately, independent of operation completion.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa80cd3f104b920c0c2f6bf7cff50fc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80cd3f104b920c0c2f6bf7cff50fc15">&#9670;&nbsp;</a></span>ucp_atomic_add64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_add64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> with opcode UCP_ATOMIC_POST_OP_ADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 64 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes the sum of the original remote value and the operand value (<em>add</em>) is stored in remote memory. The call to the routine returns immediately, independent of operation completion.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga0c777d7d1c59e01151ef5e3fcd7e5b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c777d7d1c59e01151ef5e3fcd7e5b94">&#9670;&nbsp;</a></span>ucp_atomic_fadd32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_fadd32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_FADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 32 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes, the original remote value is stored in the local memory <em>result</em>, and the sum of the original remote value and the operand value is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga7435bc5d5e2c4fb6b491d457ab65596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7435bc5d5e2c4fb6b491d457ab65596b">&#9670;&nbsp;</a></span>ucp_atomic_fadd64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_fadd64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_FADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 64 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes, the original remote value is stored in the local memory <em>result</em>, and the sum of the original remote value and the operand value is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga43118f9d5e6d8fdfa518887218468bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43118f9d5e6d8fdfa518887218468bb3">&#9670;&nbsp;</a></span>ucp_atomic_swap32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_swap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_SWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine swaps a 32 bit value between local and remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>swap</em> value is the value that is used for the swap operation. When the operation completes, the remote value is stored in the local memory <em>result</em>, and the operand value (<em>swap</em>) is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa2913e345505195a183ccc2583fb4ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2913e345505195a183ccc2583fb4ebc">&#9670;&nbsp;</a></span>ucp_atomic_swap64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_swap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_SWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine swaps a 64 bit value between local and remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>swap</em> value is the value that is used for the swap operation. When the operation completes, the remote value is stored in the local memory <em>result</em>, and the operand value (<em>swap</em>) is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga6078dddaa93c8dfdab3c18014064f0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6078dddaa93c8dfdab3c18014064f0c0">&#9670;&nbsp;</a></span>ucp_atomic_cswap32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_cswap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_CSWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine conditionally swaps a 32 bit value between local and remote memory. The swap occurs only if the condition value (<em>continue</em>) is equal to the remote value, otherwise the remote memory is not modified. The remote value is described by the combination of the remote memory address <code>remote_addr</code> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <code>swap</code> value is the value that is used to update the remote memory if the condition is true. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>Value to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gafa365c16d4c2b4fd2aba6e94fec2c92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa365c16d4c2b4fd2aba6e94fec2c92b">&#9670;&nbsp;</a></span>ucp_atomic_cswap64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_cswap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_CSWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine conditionally swaps a 64 bit value between local and remote memory. The swap occurs only if the condition value (<em>continue</em>) is equal to the remote value, otherwise the remote memory is not modified. The remote value is described by the combination of the remote memory address <code>remote_addr</code> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <code>swap</code> value is the value that is used to update the remote memory if the condition is true. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>Value to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Mar 15 2021 11:12:07 for UCX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
