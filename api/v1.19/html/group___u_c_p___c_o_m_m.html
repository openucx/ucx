<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UCX: UCP Communication routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="UCX_Logo_80x80.png"/></td>
  <td id="projectalign">
   <div id="projectname">UCX<span id="projectnumber">&#160;1.19</span>
   </div>
   <div id="projectbrief">Unified Communication X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___u_c_p___c_o_m_m.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">UCP Communication routines<div class="ingroups"><a class="el" href="group___u_c_p___a_p_i.html">Unified Communication Protocol (UCP) API</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structucp__request__attr__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#structucp__request__attr__t">ucp_request_attr_t</a></td></tr>
<tr class="memdesc:structucp__request__attr__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes of a particular request.  <a href="group___u_c_p___c_o_m_m.html#structucp__request__attr__t">More...</a><br /></td></tr>
<tr class="separator:structucp__request__attr__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__err__handler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a></td></tr>
<tr class="memdesc:structucp__err__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP endpoint error handling context.  <a href="group___u_c_p___c_o_m_m.html#structucp__err__handler">More...</a><br /></td></tr>
<tr class="separator:structucp__err__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga55df42689ef1f5621eae4d1ffb16856e"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a></td></tr>
<tr class="memdesc:ga55df42689ef1f5621eae4d1ffb16856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Tag Identifier.  <br /></td></tr>
<tr class="separator:ga55df42689ef1f5621eae4d1ffb16856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_recv_desc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a></td></tr>
<tr class="memdesc:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Message descriptor.  <br /></td></tr>
<tr class="separator:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae461587956dd56a6bc7d67b027845891"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a></td></tr>
<tr class="memdesc:gae461587956dd56a6bc7d67b027845891"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Datatype Identifier.  <br /></td></tr>
<tr class="separator:gae461587956dd56a6bc7d67b027845891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad905bbbff95166a1e9b0e9743feb677"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td></tr>
<tr class="memdesc:gaad905bbbff95166a1e9b0e9743feb677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking sends.  <br /></td></tr>
<tr class="separator:gaad905bbbff95166a1e9b0e9743feb677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee41a74074b37f96dad5b29c9af17faf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaee41a74074b37f96dad5b29c9af17faf">ucp_send_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, void *user_data)</td></tr>
<tr class="memdesc:gaee41a74074b37f96dad5b29c9af17faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking sends.  <br /></td></tr>
<tr class="separator:gaee41a74074b37f96dad5b29c9af17faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf2174ce2b86eb56f6bd4bd62865e87f1">ucp_err_handler_cb_t</a>) (void *arg, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td></tr>
<tr class="memdesc:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to process peer failure.  <br /></td></tr>
<tr class="separator:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f1988c0a6aa526d57e999b0df4acc4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga66f1988c0a6aa526d57e999b0df4acc4">ucp_err_handler_t</a></td></tr>
<tr class="memdesc:ga66f1988c0a6aa526d57e999b0df4acc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP endpoint error handling context.  <br /></td></tr>
<tr class="separator:ga66f1988c0a6aa526d57e999b0df4acc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length)</td></tr>
<tr class="memdesc:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking stream oriented receives.  <br /></td></tr>
<tr class="separator:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e253400533137ba2a5a49a111a9ee8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf9e253400533137ba2a5a49a111a9ee8">ucp_stream_recv_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td></tr>
<tr class="memdesc:gaf9e253400533137ba2a5a49a111a9ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking stream receives ucp_stream_recv_nbx call.  <br /></td></tr>
<tr class="separator:gaf9e253400533137ba2a5a49a111a9ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ac0fe5665d15fab5cd254af9b07758"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga00ac0fe5665d15fab5cd254af9b07758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking tag receives.  <br /></td></tr>
<tr class="separator:ga00ac0fe5665d15fab5cd254af9b07758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e110cf7c85ed5f281bd52438488d75"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga70e110cf7c85ed5f281bd52438488d75">ucp_tag_recv_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *tag_info, void *user_data)</td></tr>
<tr class="memdesc:ga70e110cf7c85ed5f281bd52438488d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking tag receives ucp_tag_recv_nbx call.  <br /></td></tr>
<tr class="separator:ga70e110cf7c85ed5f281bd52438488d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242399982563973351591516039dd74b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga242399982563973351591516039dd74b">ucp_am_recv_data_nbx_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td></tr>
<tr class="memdesc:ga242399982563973351591516039dd74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking Active Message receives.  <br /></td></tr>
<tr class="separator:ga242399982563973351591516039dd74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5c2ee7516e48146c044e3d9e2a2ed380"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b">UCP_ATOMIC_OP_ADD</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb">UCP_ATOMIC_OP_SWAP</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a">UCP_ATOMIC_OP_CSWAP</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3">UCP_ATOMIC_OP_AND</a>
, <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e">UCP_ATOMIC_OP_OR</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243">UCP_ATOMIC_OP_XOR</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380a0983496b62f2d28cf043966793c6bb0b">UCP_ATOMIC_OP_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:ga5c2ee7516e48146c044e3d9e2a2ed380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_op_nbx.  <a href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">More...</a><br /></td></tr>
<tr class="separator:ga5c2ee7516e48146c044e3d9e2a2ed380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c">UCP_STREAM_RECV_FLAG_WAITALL</a> = UCS_BIT(0)
 }</td></tr>
<tr class="memdesc:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to define behavior of <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> function.  <a href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">More...</a><br /></td></tr>
<tr class="separator:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fae646dd1668efba6efe49a35a6610"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996">UCP_OP_ATTR_FIELD_REQUEST</a> = UCS_BIT(0)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602">UCP_OP_ATTR_FIELD_CALLBACK</a> = UCS_BIT(1)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610af6f932f15331fe7c9efacbfe2578e5ec">UCP_OP_ATTR_FIELD_USER_DATA</a> = UCS_BIT(2)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a354ef92dd9352dfccc859cd2ca3558d8">UCP_OP_ATTR_FIELD_DATATYPE</a> = UCS_BIT(3)
, <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a2f2586686e21b2700fd7cd4a8efb5a1b">UCP_OP_ATTR_FIELD_FLAGS</a> = UCS_BIT(4)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0">UCP_OP_ATTR_FIELD_REPLY_BUFFER</a> = UCS_BIT(5)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a768b4c6759502c34b0051ba33c0d05b3">UCP_OP_ATTR_FIELD_MEMORY_TYPE</a> = UCS_BIT(6)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610ac5a4c17a81a2efefae5e338479ae06cb">UCP_OP_ATTR_FIELD_RECV_INFO</a> = UCS_BIT(7)
, <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a84426c4dea4dceee1b015c3ccdcb7a78">UCP_OP_ATTR_FIELD_MEMH</a> = UCS_BIT(8)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a8805045d48573e9aa5751b439be114d0">UCP_OP_ATTR_FLAG_NO_IMM_CMPL</a> = UCS_BIT(16)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a69a2066ee5f68e57021f622b0cc859a8">UCP_OP_ATTR_FLAG_FAST_CMPL</a> = UCS_BIT(17)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610aeb35a090d86119cfd25d4e82753e943f">UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL</a> = UCS_BIT(18)
, <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a405517272bc4319aa3b49638f5626c7b">UCP_OP_ATTR_FLAG_MULTI_SEND</a> = UCS_BIT(19)
<br />
 }</td></tr>
<tr class="memdesc:ga67fae646dd1668efba6efe49a35a6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP operation fields and flags.  <a href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">More...</a><br /></td></tr>
<tr class="separator:ga67fae646dd1668efba6efe49a35a6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab383d860475f8917f51afb542e7d02ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gab383d860475f8917f51afb542e7d02ff">ucp_req_attr_field</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#ggab383d860475f8917f51afb542e7d02ffa45086e70d5035d92a601605a689178b9">UCP_REQUEST_ATTR_FIELD_INFO_STRING</a> = UCS_BIT(0)
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggab383d860475f8917f51afb542e7d02ffaaae11c040c811d14362cbbc47ea9f772">UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE</a> = UCS_BIT(1)
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggab383d860475f8917f51afb542e7d02ffa9d41f03b4a79e21265ad15f87d3ff8ed">UCP_REQUEST_ATTR_FIELD_STATUS</a> = UCS_BIT(2)
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggab383d860475f8917f51afb542e7d02ffa7a1764b4ce21085ecbbdd13a1f183df5">UCP_REQUEST_ATTR_FIELD_MEM_TYPE</a> = UCS_BIT(3)
 }</td></tr>
<tr class="memdesc:gab383d860475f8917f51afb542e7d02ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP request query attributes.  <a href="group___u_c_p___c_o_m_m.html#gab383d860475f8917f51afb542e7d02ff">More...</a><br /></td></tr>
<tr class="separator:gab383d860475f8917f51afb542e7d02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487a3c588a11e42b9f313f0c9e2ead3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga487a3c588a11e42b9f313f0c9e2ead3b">ucp_am_recv_attr_t</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#gga487a3c588a11e42b9f313f0c9e2ead3ba7a4057be7a4cc3bba470da4f8ed63259">UCP_AM_RECV_ATTR_FIELD_REPLY_EP</a> = UCS_BIT(0)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga487a3c588a11e42b9f313f0c9e2ead3baf77ecce2987e81bf773a48363767b77e">UCP_AM_RECV_ATTR_FLAG_DATA</a> = UCS_BIT(16)
, <a class="el" href="group___u_c_p___c_o_m_m.html#gga487a3c588a11e42b9f313f0c9e2ead3baf9a8d75af5b826d7563863591a98714f">UCP_AM_RECV_ATTR_FLAG_RNDV</a> = UCS_BIT(17)
 }</td></tr>
<tr class="memdesc:ga487a3c588a11e42b9f313f0c9e2ead3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP AM receive data parameter fields and flags.  <a href="group___u_c_p___c_o_m_m.html#ga487a3c588a11e42b9f313f0c9e2ead3b">More...</a><br /></td></tr>
<tr class="separator:ga487a3c588a11e42b9f313f0c9e2ead3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae021145933ffa033b8327bb7bf2533"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaeae021145933ffa033b8327bb7bf2533">ucp_am_handler_param_field</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a4b9788659b793630cee9bc027add35ad">UCP_AM_HANDLER_PARAM_FIELD_ID</a> = UCS_BIT(0)
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a99854985610ec532f0c83e36b3cadb3d">UCP_AM_HANDLER_PARAM_FIELD_FLAGS</a> = UCS_BIT(1)
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a6c2a2d3fe9c7118d3513833ad452cb69">UCP_AM_HANDLER_PARAM_FIELD_CB</a> = UCS_BIT(2)
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggaeae021145933ffa033b8327bb7bf2533a23622f1a9046a0b59d1519732e2b73ff">UCP_AM_HANDLER_PARAM_FIELD_ARG</a> = UCS_BIT(3)
 }</td></tr>
<tr class="memdesc:gaeae021145933ffa033b8327bb7bf2533"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP AM receive data parameters fields and flags.  <a href="group___u_c_p___c_o_m_m.html#gaeae021145933ffa033b8327bb7bf2533">More...</a><br /></td></tr>
<tr class="separator:gaeae021145933ffa033b8327bb7bf2533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0">UCP_ATOMIC_POST_OP_ADD</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4">UCP_ATOMIC_POST_OP_AND</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460">UCP_ATOMIC_POST_OP_OR</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89">UCP_ATOMIC_POST_OP_XOR</a>
, <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d">UCP_ATOMIC_POST_OP_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_post.  <a href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">More...</a><br /></td></tr>
<tr class="separator:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037">UCP_ATOMIC_FETCH_OP_FADD</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069">UCP_ATOMIC_FETCH_OP_SWAP</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c">UCP_ATOMIC_FETCH_OP_CSWAP</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3">UCP_ATOMIC_FETCH_OP_FAND</a>
, <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59">UCP_ATOMIC_FETCH_OP_FOR</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049">UCP_ATOMIC_FETCH_OP_FXOR</a>
, <a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05">UCP_ATOMIC_FETCH_OP_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_fetch.  <a href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">More...</a><br /></td></tr>
<tr class="separator:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafc247802373bbe39e9866745e102a064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gafc247802373bbe39e9866745e102a064">ucp_request_query</a> (void *request, <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__request__attr__t">ucp_request_attr_t</a> *attr)</td></tr>
<tr class="memdesc:gafc247802373bbe39e9866745e102a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about ucp_request.  <br /></td></tr>
<tr class="separator:gafc247802373bbe39e9866745e102a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8ab214f35828ee4608d73442e8c372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga4b8ab214f35828ee4608d73442e8c372">ucp_am_send_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, unsigned id, const void *header, size_t header_length, const void *buffer, size_t count, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga4b8ab214f35828ee4608d73442e8c372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Active Message.  <br /></td></tr>
<tr class="separator:ga4b8ab214f35828ee4608d73442e8c372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefaaa5e0a154efe496ae5bb7f2bf71f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaefaaa5e0a154efe496ae5bb7f2bf71f3">ucp_am_recv_data_nbx</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *data_desc, void *buffer, size_t count, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gaefaaa5e0a154efe496ae5bb7f2bf71f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Active Message as defined by provided data descriptor.  <br /></td></tr>
<tr class="separator:gaefaaa5e0a154efe496ae5bb7f2bf71f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45570903fc3ce01e7e5c0cd241f516f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga45570903fc3ce01e7e5c0cd241f516f9">ucp_am_data_release</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *data)</td></tr>
<tr class="memdesc:ga45570903fc3ce01e7e5c0cd241f516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases Active Message data.  <br /></td></tr>
<tr class="separator:ga45570903fc3ce01e7e5c0cd241f516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fe6efe6b05e4e78f58bee68c68b252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae9fe6efe6b05e4e78f58bee68c68b252">ucp_stream_send_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gae9fe6efe6b05e4e78f58bee68c68b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream send operation.  <br /></td></tr>
<tr class="separator:gae9fe6efe6b05e4e78f58bee68c68b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8323878b60f426c630d4ff8996ede3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga8323878b60f426c630d4ff8996ede3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operation.  <br /></td></tr>
<tr class="separator:ga8323878b60f426c630d4ff8996ede3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d96a2aac42fe99ce0c79f15dda8bd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0d96a2aac42fe99ce0c79f15dda8bd06">ucp_tag_send_sync_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga0d96a2aac42fe99ce0c79f15dda8bd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking synchronous tagged-send operation.  <br /></td></tr>
<tr class="separator:ga0d96a2aac42fe99ce0c79f15dda8bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30494ce33e63823c81c2c5b3656d25c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga30494ce33e63823c81c2c5b3656d25c3">ucp_stream_recv_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, size_t *length, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga30494ce33e63823c81c2c5b3656d25c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of structured data into a user-supplied buffer.  <br /></td></tr>
<tr class="separator:ga30494ce33e63823c81c2c5b3656d25c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f307f4765eb5410f24ac27986b59d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, size_t *length)</td></tr>
<tr class="memdesc:ga47f307f4765eb5410f24ac27986b59d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of unstructured data into a UCP-supplied buffer.  <br /></td></tr>
<tr class="separator:ga47f307f4765eb5410f24ac27986b59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa842f8ca8ad1363ed857ab938285a16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gaa842f8ca8ad1363ed857ab938285a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <br /></td></tr>
<tr class="separator:gaa842f8ca8ad1363ed857ab938285a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41668f468dc37a7634116b8210815f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, int remove, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga41668f468dc37a7634116b8210815f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking probe and return a message.  <br /></td></tr>
<tr class="separator:ga41668f468dc37a7634116b8210815f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c61d44f18362bdaf8fca3122efcea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga48c61d44f18362bdaf8fca3122efcea6">ucp_tag_msg_recv_nbx</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> message, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga48c61d44f18362bdaf8fca3122efcea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive operation for a probed message.  <br /></td></tr>
<tr class="separator:ga48c61d44f18362bdaf8fca3122efcea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e7b9b70b782140e63544b8613a5fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga29e7b9b70b782140e63544b8613a5fe7">ucp_put_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga29e7b9b70b782140e63544b8613a5fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory put operation.  <br /></td></tr>
<tr class="separator:ga29e7b9b70b782140e63544b8613a5fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06c6521592661a8123c11426074d880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa06c6521592661a8123c11426074d880">ucp_get_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:gaa06c6521592661a8123c11426074d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory get operation.  <br /></td></tr>
<tr class="separator:gaa06c6521592661a8123c11426074d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087e2cad02e84cf1230684362562aa46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a> opcode, const void *buffer, size_t count, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *param)</td></tr>
<tr class="memdesc:ga087e2cad02e84cf1230684362562aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic memory operation.  <br /></td></tr>
<tr class="separator:ga087e2cad02e84cf1230684362562aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae082ad7af428645ebe6e469d3d06a757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a> (void *request)</td></tr>
<tr class="memdesc:gae082ad7af428645ebe6e469d3d06a757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of non-blocking request.  <br /></td></tr>
<tr class="separator:gae082ad7af428645ebe6e469d3d06a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga707cbbef8cdcf90fa7cf63c922ef2c7f">ucp_tag_recv_request_test</a> (void *request, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status and currently available state of non-blocking request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> routine.  <br /></td></tr>
<tr class="separator:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga4d8d8823b24cb25dcab8bf44c72fa25e">ucp_stream_recv_request_test</a> (void *request, size_t *length_p)</td></tr>
<tr class="memdesc:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status and currently available state of non-blocking request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> routine.  <br /></td></tr>
<tr class="separator:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga3553f89a61d6b40af4633a2e7c84fc1d">ucp_request_cancel</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *request)</td></tr>
<tr class="memdesc:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an outstanding communications request.  <br /></td></tr>
<tr class="separator:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga1d1c1c1b2caf4f26c9872e1d708d5f68">ucp_stream_data_release</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *data)</td></tr>
<tr class="memdesc:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release UCP data buffer returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a>.  <br /></td></tr>
<tr class="separator:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8e46f5953d464382b21edef3ec9994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> (void *request)</td></tr>
<tr class="memdesc:ga0e8e46f5953d464382b21edef3ec9994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a communications request.  <br /></td></tr>
<tr class="separator:ga0e8e46f5953d464382b21edef3ec9994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896e6f781c5fb026a6e25b0151bdb745"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga896e6f781c5fb026a6e25b0151bdb745">ucp_request_alloc</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:ga896e6f781c5fb026a6e25b0151bdb745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty communications request.  <br /></td></tr>
<tr class="separator:ga896e6f781c5fb026a6e25b0151bdb745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432e478b97575b21855074a45d54520d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga432e478b97575b21855074a45d54520d">ucp_request_is_completed</a> (void *request)</td></tr>
<tr class="separator:ga432e478b97575b21855074a45d54520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b0a27cf8a3239decabad6a9104eb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31">ucp_put</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga85b0a27cf8a3239decabad6a9104eb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remote memory put operation.  <br /></td></tr>
<tr class="separator:ga85b0a27cf8a3239decabad6a9104eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a465cff6c1691106430564899f6f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf4a465cff6c1691106430564899f6f3e">ucp_get</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaf4a465cff6c1691106430564899f6f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remote memory get operation.  <br /></td></tr>
<tr class="separator:gaf4a465cff6c1691106430564899f6f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa042d7e76314e1d7ea9717d4adacde7b">ucp_atomic_add32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic add operation for 32 bit integers.  <br /></td></tr>
<tr class="separator:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa80cd3f104b920c0c2f6bf7cff50fc15">ucp_atomic_add64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic add operation for 64 bit integers.  <br /></td></tr>
<tr class="separator:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0c777d7d1c59e01151ef5e3fcd7e5b94">ucp_atomic_fadd32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic fetch and add operation for 32 bit integers.  <br /></td></tr>
<tr class="separator:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga7435bc5d5e2c4fb6b491d457ab65596b">ucp_atomic_fadd64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic fetch and add operation for 64 bit integers.  <br /></td></tr>
<tr class="separator:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43118f9d5e6d8fdfa518887218468bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga43118f9d5e6d8fdfa518887218468bb3">ucp_atomic_swap32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga43118f9d5e6d8fdfa518887218468bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic swap operation for 32 bit values.  <br /></td></tr>
<tr class="separator:ga43118f9d5e6d8fdfa518887218468bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2913e345505195a183ccc2583fb4ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa2913e345505195a183ccc2583fb4ebc">ucp_atomic_swap64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:gaa2913e345505195a183ccc2583fb4ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic swap operation for 64 bit values.  <br /></td></tr>
<tr class="separator:gaa2913e345505195a183ccc2583fb4ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6078dddaa93c8dfdab3c18014064f0c0">ucp_atomic_cswap32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic conditional swap (cswap) operation for 32 bit values.  <br /></td></tr>
<tr class="separator:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gafa365c16d4c2b4fd2aba6e94fec2c92b">ucp_atomic_cswap64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic conditional swap (cswap) operation for 64 bit values.  <br /></td></tr>
<tr class="separator:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ec21811930b6b6fb8eab500b8c730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga94ec21811930b6b6fb8eab500b8c730d">ucp_am_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint16_t id, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb, unsigned flags)</td></tr>
<tr class="memdesc:ga94ec21811930b6b6fb8eab500b8c730d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Active Message.  <br /></td></tr>
<tr class="separator:ga94ec21811930b6b6fb8eab500b8c730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga9022ff0ebb56cac81f6ba81bb28f71b3">ucp_stream_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb, unsigned flags)</td></tr>
<tr class="memdesc:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream send operation.  <br /></td></tr>
<tr class="separator:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a> cb, size_t *length, unsigned flags)</td></tr>
<tr class="memdesc:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of structured data into a user-supplied buffer.  <br /></td></tr>
<tr class="separator:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7343bd638924e5518041311d5c1dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gaae7343bd638924e5518041311d5c1dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operations.  <br /></td></tr>
<tr class="separator:gaae7343bd638924e5518041311d5c1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90aa964e14fef59b4e3bd9120cca669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, void *req)</td></tr>
<tr class="memdesc:gad90aa964e14fef59b4e3bd9120cca669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operations with user provided request.  <br /></td></tr>
<tr class="separator:gad90aa964e14fef59b4e3bd9120cca669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd3e1ccae2ef34463e8313d09d3db17f">ucp_tag_send_sync_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking synchronous tagged-send operation.  <br /></td></tr>
<tr class="separator:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb24cdfc33dfb2886551b51843aa6304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a> cb)</td></tr>
<tr class="memdesc:gaeb24cdfc33dfb2886551b51843aa6304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <br /></td></tr>
<tr class="separator:gaeb24cdfc33dfb2886551b51843aa6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">ucp_tag_recv_nbr</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, void *req)</td></tr>
<tr class="memdesc:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <br /></td></tr>
<tr class="separator:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> message, <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a> cb)</td></tr>
<tr class="memdesc:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive operation for a probed message.  <br /></td></tr>
<tr class="separator:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">ucp_put_nbi</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking implicit remote memory put operation.  <br /></td></tr>
<tr class="separator:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba986b2bde69c215abd5766dbceeb18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga1ba986b2bde69c215abd5766dbceeb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory put operation.  <br /></td></tr>
<tr class="separator:ga1ba986b2bde69c215abd5766dbceeb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3597f699227d598651f6630fbd7968b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae3597f699227d598651f6630fbd7968b">ucp_get_nbi</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gae3597f699227d598651f6630fbd7968b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking implicit remote memory get operation.  <br /></td></tr>
<tr class="separator:gae3597f699227d598651f6630fbd7968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga7cb68811f53a69d37fd16e8ddb46e23b">ucp_get_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory get operation.  <br /></td></tr>
<tr class="separator:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839312fb4de5e786daacb4fa071d61df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a> opcode, uint64_t value, size_t op_size, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga839312fb4de5e786daacb4fa071d61df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic memory operation.  <br /></td></tr>
<tr class="separator:ga839312fb4de5e786daacb4fa071d61df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a1a4a517797eb8c5c96ac8841437de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a> opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga43a1a4a517797eb8c5c96ac8841437de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic fetch operation.  <br /></td></tr>
<tr class="separator:ga43a1a4a517797eb8c5c96ac8841437de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UCP Communication routines </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structucp__request__attr__t" id="structucp__request__attr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structucp__request__attr__t">&#9670;&#160;</a></span>ucp_request_attr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_request_attr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a311396d670dcb5ca9941dc17a8ad23d7" name="a311396d670dcb5ca9941dc17a8ad23d7"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___c_o_m_m.html#gab383d860475f8917f51afb542e7d02ff">ucp_req_attr_field</a>. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa284657c27e1a8d6d2653f12cfb61bc5" name="aa284657c27e1a8d6d2653f12cfb61bc5"></a>char *</td>
<td class="fieldname">
debug_string</td>
<td class="fielddoc">
<p>Pointer to allocated string of size <a class="el" href="group___u_c_p___c_o_m_m.html#a871b3929bfe0b97d249016e57fd2fdd7">debug_string_size</a> that will be filled with debug information about transports and protocols that were selected to complete the request. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a871b3929bfe0b97d249016e57fd2fdd7" name="a871b3929bfe0b97d249016e57fd2fdd7"></a>size_t</td>
<td class="fieldname">
debug_string_size</td>
<td class="fielddoc">
<p>Size of the <a class="el" href="group___u_c_p___c_o_m_m.html#aa284657c27e1a8d6d2653f12cfb61bc5">debug_string</a>. String will be filled up to this size. Maximum possible size debug string can be obtained by querying the worker via <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query</a>. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3df010dde5b9a67b62bd354f0af3fc93" name="a3df010dde5b9a67b62bd354f0af3fc93"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
<p>Status of the request. The same as <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a>. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a86e23d8d22c973be0f86ea56adfd5678" name="a86e23d8d22c973be0f86ea56adfd5678"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga0da130a6b3524f3f7642b76f698903c7">ucs_memory_type_t</a></td>
<td class="fieldname">
mem_type</td>
<td class="fielddoc">
<p>Detected memory type of the buffer passed to the operation. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__err__handler" id="structucp__err__handler"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structucp__err__handler">&#9670;&#160;</a></span>ucp_err_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_err_handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure should be initialized in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gae071db9736cd54afebe6f619401c6617">ucp_ep_params_t</a> to handle peer failure </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0bf3f446a1821a62dd3a300584792e33" name="a0bf3f446a1821a62dd3a300584792e33"></a><a class="el" href="group___u_c_p___c_o_m_m.html#gaf2174ce2b86eb56f6bd4bd62865e87f1">ucp_err_handler_cb_t</a></td>
<td class="fieldname">
cb</td>
<td class="fielddoc">
<p>Error handler callback, if NULL, will not be called. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7e49e1843e1adab5561e5fc2b2e1afb1" name="a7e49e1843e1adab5561e5fc2b2e1afb1"></a>void *</td>
<td class="fieldname">
arg</td>
<td class="fielddoc">
<p>User defined argument associated with an endpoint, it will be overridden by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#adaf49e16ee05400f715f432e442336cb">ucp_ep_params_t::user_data</a> if both are set. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga55df42689ef1f5621eae4d1ffb16856e" name="ga55df42689ef1f5621eae4d1ffb16856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55df42689ef1f5621eae4d1ffb16856e">&#9670;&#160;</a></span>ucp_tag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP tag identifier is a 64bit object used for message identification. UCP tag send and receive operations use the object for an implementation tag matching semantics (derivative of MPI tag matching semantics). </p>

</div>
</div>
<a id="ga6a8b5741a4e66d7e890d31ef7cbf88ec" name="ga6a8b5741a4e66d7e890d31ef7cbf88ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8b5741a4e66d7e890d31ef7cbf88ec">&#9670;&#160;</a></span>ucp_tag_message_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_recv_desc* <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP Message descriptor is an opaque handle for a message returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb</a>. This handle can be passed to <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb</a> in order to receive the message data to a specific buffer. </p>

</div>
</div>
<a id="gae461587956dd56a6bc7d67b027845891" name="gae461587956dd56a6bc7d67b027845891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae461587956dd56a6bc7d67b027845891">&#9670;&#160;</a></span>ucp_datatype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP datatype identifier is a 64bit object used for datatype identification. Predefined UCP identifiers are defined by <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga50b3b4e641a197264e963d91be480b6c">ucp_dt_type</a>. </p>

</div>
</div>
<a id="gaad905bbbff95166a1e9b0e9743feb677" name="gaad905bbbff95166a1e9b0e9743feb677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad905bbbff95166a1e9b0e9743feb677">&#9670;&#160;</a></span>ucp_send_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_send_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">send operation</a> is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed send request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee41a74074b37f96dad5b29c9af17faf" name="gaee41a74074b37f96dad5b29c9af17faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee41a74074b37f96dad5b29c9af17faf">&#9670;&#160;</a></span>ucp_send_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_send_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#ga4b8ab214f35828ee4608d73442e8c372">ucp_am_send_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#gae9fe6efe6b05e4e78f58bee68c68b252">ucp_stream_send_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#ga29e7b9b70b782140e63544b8613a5fe7">ucp_put_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#gaa06c6521592661a8123c11426074d880">ucp_get_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> or any other "send operation" is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed send request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a48">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaf2174ce2b86eb56f6bd4bd62865e87f1" name="gaf2174ce2b86eb56f6bd4bd62865e87f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2174ce2b86eb56f6bd4bd62865e87f1">&#9670;&#160;</a></span>ucp_err_handler_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_err_handler_cb_t) (void *arg, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked when transport level error detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint to handle transport level error. Upon return from the callback, this <em>ep</em> is no longer usable and all subsequent operations on this <em>ep</em> will fail with the error code passed in <em>status</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66f1988c0a6aa526d57e999b0df4acc4" name="ga66f1988c0a6aa526d57e999b0df4acc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f1988c0a6aa526d57e999b0df4acc4">&#9670;&#160;</a></span>ucp_err_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a> <a class="el" href="group___u_c_p___c_o_m_m.html#ga66f1988c0a6aa526d57e999b0df4acc4">ucp_err_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure should be initialized in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gae071db9736cd54afebe6f619401c6617">ucp_ep_params_t</a> to handle peer failure </p>

</div>
</div>
<a id="ga6a6234b8497006e26ba02f10ddc0bbf5" name="ga6a6234b8497006e26ba02f10ddc0bbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6234b8497006e26ba02f10ddc0bbf5">&#9670;&#160;</a></span>ucp_stream_recv_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_stream_recv_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9e253400533137ba2a5a49a111a9ee8" name="gaf9e253400533137ba2a5a49a111a9ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e253400533137ba2a5a49a111a9ee8">&#9670;&#160;</a></span>ucp_stream_recv_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_stream_recv_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#ga30494ce33e63823c81c2c5b3656d25c3">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always on the boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00ac0fe5665d15fab5cd254af9b07758" name="ga00ac0fe5665d15fab5cd254af9b07758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00ac0fe5665d15fab5cd254af9b07758">&#9670;&#160;</a></span>ucp_tag_recv_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_tag_recv_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCS_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. If the data can not fit into the receive buffer the <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558aef3defd5d754266db882e079fad7c544">UCS_ERR_MESSAGE_TRUNCATED</a> error code is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">Completion information</a> The <em>info</em> descriptor is Valid only if the status is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70e110cf7c85ed5f281bd52438488d75" name="ga70e110cf7c85ed5f281bd52438488d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e110cf7c85ed5f281bd52438488d75">&#9670;&#160;</a></span>ucp_tag_recv_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_tag_recv_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *tag_info, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the receive operation was completed successfully UCS_OK is returned. If send operation was canceled, UCS_ERR_CANCELED is returned. If the data can not fit into the receive buffer the <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558aef3defd5d754266db882e079fad7c544">UCS_ERR_MESSAGE_TRUNCATED</a> error code is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_info</td><td><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">Completion information</a> The <em>info</em> descriptor is Valid only if the status is UCS_OK. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga242399982563973351591516039dd74b" name="ga242399982563973351591516039dd74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242399982563973351591516039dd74b">&#9670;&#160;</a></span>ucp_am_recv_data_nbx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_am_recv_data_nbx_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaefaaa5e0a154efe496ae5bb7f2bf71f3">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the receive operation was completed successfully UCS_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed to "user_data" value, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5c2ee7516e48146c044e3d9e2a2ed380" name="ga5c2ee7516e48146c044e3d9e2a2ed380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c2ee7516e48146c044e3d9e2a2ed380">&#9670;&#160;</a></span>ucp_atomic_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines which atomic memory operation should be performed by the <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> routine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b" name="gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b"></a>UCP_ATOMIC_OP_ADD&#160;</td><td class="fielddoc"><p>Atomic add <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb" name="gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb"></a>UCP_ATOMIC_OP_SWAP&#160;</td><td class="fielddoc"><p>Atomic swap </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a" name="gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a"></a>UCP_ATOMIC_OP_CSWAP&#160;</td><td class="fielddoc"><p>Atomic conditional swap </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3" name="gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3"></a>UCP_ATOMIC_OP_AND&#160;</td><td class="fielddoc"><p>Atomic and <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e" name="gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e"></a>UCP_ATOMIC_OP_OR&#160;</td><td class="fielddoc"><p>Atomic or <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243" name="gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243"></a>UCP_ATOMIC_OP_XOR&#160;</td><td class="fielddoc"><p>Atomic xor <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5c2ee7516e48146c044e3d9e2a2ed380a0983496b62f2d28cf043966793c6bb0b" name="gga5c2ee7516e48146c044e3d9e2a2ed380a0983496b62f2d28cf043966793c6bb0b"></a>UCP_ATOMIC_OP_LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gab471a9c7ab815e3d3ad7af80253f5cc2" name="gab471a9c7ab815e3d3ad7af80253f5cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab471a9c7ab815e3d3ad7af80253f5cc2">&#9670;&#160;</a></span>ucp_stream_recv_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines behavior of <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c" name="ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c"></a>UCP_STREAM_RECV_FLAG_WAITALL&#160;</td><td class="fielddoc"><p>This flag requests that the operation will not be completed until all requested data is received and placed in the user buffer. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga67fae646dd1668efba6efe49a35a6610" name="ga67fae646dd1668efba6efe49a35a6610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67fae646dd1668efba6efe49a35a6610">&#9670;&#160;</a></span>ucp_op_attr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> are present and operation flags are used. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996" name="gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996"></a>UCP_OP_ATTR_FIELD_REQUEST&#160;</td><td class="fielddoc"><p>request field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602" name="gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602"></a>UCP_OP_ATTR_FIELD_CALLBACK&#160;</td><td class="fielddoc"><p>cb field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610af6f932f15331fe7c9efacbfe2578e5ec" name="gga67fae646dd1668efba6efe49a35a6610af6f932f15331fe7c9efacbfe2578e5ec"></a>UCP_OP_ATTR_FIELD_USER_DATA&#160;</td><td class="fielddoc"><p>user_data field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a354ef92dd9352dfccc859cd2ca3558d8" name="gga67fae646dd1668efba6efe49a35a6610a354ef92dd9352dfccc859cd2ca3558d8"></a>UCP_OP_ATTR_FIELD_DATATYPE&#160;</td><td class="fielddoc"><p>datatype field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a2f2586686e21b2700fd7cd4a8efb5a1b" name="gga67fae646dd1668efba6efe49a35a6610a2f2586686e21b2700fd7cd4a8efb5a1b"></a>UCP_OP_ATTR_FIELD_FLAGS&#160;</td><td class="fielddoc"><p>operation-specific flags </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0" name="gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0"></a>UCP_OP_ATTR_FIELD_REPLY_BUFFER&#160;</td><td class="fielddoc"><p>reply_buffer field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a768b4c6759502c34b0051ba33c0d05b3" name="gga67fae646dd1668efba6efe49a35a6610a768b4c6759502c34b0051ba33c0d05b3"></a>UCP_OP_ATTR_FIELD_MEMORY_TYPE&#160;</td><td class="fielddoc"><p>memory type field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610ac5a4c17a81a2efefae5e338479ae06cb" name="gga67fae646dd1668efba6efe49a35a6610ac5a4c17a81a2efefae5e338479ae06cb"></a>UCP_OP_ATTR_FIELD_RECV_INFO&#160;</td><td class="fielddoc"><p>recv_info field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a84426c4dea4dceee1b015c3ccdcb7a78" name="gga67fae646dd1668efba6efe49a35a6610a84426c4dea4dceee1b015c3ccdcb7a78"></a>UCP_OP_ATTR_FIELD_MEMH&#160;</td><td class="fielddoc"><p>memory handle field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a8805045d48573e9aa5751b439be114d0" name="gga67fae646dd1668efba6efe49a35a6610a8805045d48573e9aa5751b439be114d0"></a>UCP_OP_ATTR_FLAG_NO_IMM_CMPL&#160;</td><td class="fielddoc"><p>Deny immediate completion, i.e NULL cannot be returned. If a completion callback is provided, it can be called before the function returns. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a69a2066ee5f68e57021f622b0cc859a8" name="gga67fae646dd1668efba6efe49a35a6610a69a2066ee5f68e57021f622b0cc859a8"></a>UCP_OP_ATTR_FLAG_FAST_CMPL&#160;</td><td class="fielddoc"><p>expedite local completion, even if it delays remote data delivery. Note for implementer: this option can disable zero copy and/or rendezvous protocols which require synchronization with the remote peer before releasing the local send buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610aeb35a090d86119cfd25d4e82753e943f" name="gga67fae646dd1668efba6efe49a35a6610aeb35a090d86119cfd25d4e82753e943f"></a>UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL&#160;</td><td class="fielddoc"><p>force immediate complete operation, fail if the operation cannot be completed immediately </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67fae646dd1668efba6efe49a35a6610a405517272bc4319aa3b49638f5626c7b" name="gga67fae646dd1668efba6efe49a35a6610a405517272bc4319aa3b49638f5626c7b"></a>UCP_OP_ATTR_FLAG_MULTI_SEND&#160;</td><td class="fielddoc"><p>optimize for bandwidth of multiple in-flight operations, rather than for the latency of a single operation. This flag and UCP_OP_ATTR_FLAG_FAST_CMPL are mutually exclusive. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab383d860475f8917f51afb542e7d02ff" name="gab383d860475f8917f51afb542e7d02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab383d860475f8917f51afb542e7d02ff">&#9670;&#160;</a></span>ucp_req_attr_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gab383d860475f8917f51afb542e7d02ff">ucp_req_attr_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__request__attr__t">ucp_request_attr_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab383d860475f8917f51afb542e7d02ffa45086e70d5035d92a601605a689178b9" name="ggab383d860475f8917f51afb542e7d02ffa45086e70d5035d92a601605a689178b9"></a>UCP_REQUEST_ATTR_FIELD_INFO_STRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggab383d860475f8917f51afb542e7d02ffaaae11c040c811d14362cbbc47ea9f772" name="ggab383d860475f8917f51afb542e7d02ffaaae11c040c811d14362cbbc47ea9f772"></a>UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggab383d860475f8917f51afb542e7d02ffa9d41f03b4a79e21265ad15f87d3ff8ed" name="ggab383d860475f8917f51afb542e7d02ffa9d41f03b4a79e21265ad15f87d3ff8ed"></a>UCP_REQUEST_ATTR_FIELD_STATUS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggab383d860475f8917f51afb542e7d02ffa7a1764b4ce21085ecbbdd13a1f183df5" name="ggab383d860475f8917f51afb542e7d02ffa7a1764b4ce21085ecbbdd13a1f183df5"></a>UCP_REQUEST_ATTR_FIELD_MEM_TYPE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga487a3c588a11e42b9f313f0c9e2ead3b" name="ga487a3c588a11e42b9f313f0c9e2ead3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487a3c588a11e42b9f313f0c9e2ead3b">&#9670;&#160;</a></span>ucp_am_recv_attr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#ga487a3c588a11e42b9f313f0c9e2ead3b">ucp_am_recv_attr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga435d870d0afb413f0bc780809f1db2ef">ucp_am_recv_param_t</a> are present and receive operation flags are used. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga487a3c588a11e42b9f313f0c9e2ead3ba7a4057be7a4cc3bba470da4f8ed63259" name="gga487a3c588a11e42b9f313f0c9e2ead3ba7a4057be7a4cc3bba470da4f8ed63259"></a>UCP_AM_RECV_ATTR_FIELD_REPLY_EP&#160;</td><td class="fielddoc"><p>reply_ep field </p>
</td></tr>
<tr><td class="fieldname"><a id="gga487a3c588a11e42b9f313f0c9e2ead3baf77ecce2987e81bf773a48363767b77e" name="gga487a3c588a11e42b9f313f0c9e2ead3baf77ecce2987e81bf773a48363767b77e"></a>UCP_AM_RECV_ATTR_FLAG_DATA&#160;</td><td class="fielddoc"><p>Indicates that the data provided in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a> callback can be held by the user. If UCS_INPROGRESS is returned from the callback, the data parameter will persist and the user has to call <a class="el" href="group___u_c_p___c_o_m_m.html#ga45570903fc3ce01e7e5c0cd241f516f9">ucp_am_data_release</a> when data is no longer needed. This flag is mutually exclusive with <em>UCP_AM_RECV_ATTR_FLAG_RNDV</em>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga487a3c588a11e42b9f313f0c9e2ead3baf9a8d75af5b826d7563863591a98714f" name="gga487a3c588a11e42b9f313f0c9e2ead3baf9a8d75af5b826d7563863591a98714f"></a>UCP_AM_RECV_ATTR_FLAG_RNDV&#160;</td><td class="fielddoc"><p>Indicates that the arriving data was sent using rendezvous protocol. In this case <em>data</em> parameter of the <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a> points to the internal UCP descriptor, which can be used for obtaining the actual data by calling <a class="el" href="group___u_c_p___c_o_m_m.html#gaefaaa5e0a154efe496ae5bb7f2bf71f3">ucp_am_recv_data_nbx</a> routine. This flag is mutually exclusive with <em>UCP_AM_RECV_ATTR_FLAG_DATA</em>. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaeae021145933ffa033b8327bb7bf2533" name="gaeae021145933ffa033b8327bb7bf2533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeae021145933ffa033b8327bb7bf2533">&#9670;&#160;</a></span>ucp_am_handler_param_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gaeae021145933ffa033b8327bb7bf2533">ucp_am_handler_param_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga1e2efca405d525b094ad49e38d80269b">ucp_am_handler_param_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a4b9788659b793630cee9bc027add35ad" name="ggaeae021145933ffa033b8327bb7bf2533a4b9788659b793630cee9bc027add35ad"></a>UCP_AM_HANDLER_PARAM_FIELD_ID&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ad0c6157f387e18cb4d92a37a638274af">ucp_am_handler_param_t::id</a> field is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a99854985610ec532f0c83e36b3cadb3d" name="ggaeae021145933ffa033b8327bb7bf2533a99854985610ec532f0c83e36b3cadb3d"></a>UCP_AM_HANDLER_PARAM_FIELD_FLAGS&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#a061115b2dc01fb803ae8082bd41f8730">ucp_am_handler_param_t::flags</a> field is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a6c2a2d3fe9c7118d3513833ad452cb69" name="ggaeae021145933ffa033b8327bb7bf2533a6c2a2d3fe9c7118d3513833ad452cb69"></a>UCP_AM_HANDLER_PARAM_FIELD_CB&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#acd54cdefba3f3f5e145dfe2360485659">ucp_am_handler_param_t::cb</a> field is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeae021145933ffa033b8327bb7bf2533a23622f1a9046a0b59d1519732e2b73ff" name="ggaeae021145933ffa033b8327bb7bf2533a23622f1a9046a0b59d1519732e2b73ff"></a>UCP_AM_HANDLER_PARAM_FIELD_ARG&#160;</td><td class="fielddoc"><p>Indicates that <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ae1670a4926d8528fb1ec1cd3f461f13a">ucp_am_handler_param_t::arg</a> field is valid. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac5d94ea07dc4feae2708e67378ba2ad0" name="gac5d94ea07dc4feae2708e67378ba2ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d94ea07dc4feae2708e67378ba2ad0">&#9670;&#160;</a></span>ucp_atomic_post_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> and <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a> instead.</dd></dl>
<p>This enumeration defines which atomic memory operation should be performed by the ucp_atomic_post family of functions. All of these are non-fetching atomics and will not result in a request handle. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0" name="ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0"></a>UCP_ATOMIC_POST_OP_ADD&#160;</td><td class="fielddoc"><p>Atomic add </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4" name="ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4"></a>UCP_ATOMIC_POST_OP_AND&#160;</td><td class="fielddoc"><p>Atomic and </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460" name="ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460"></a>UCP_ATOMIC_POST_OP_OR&#160;</td><td class="fielddoc"><p>Atomic or <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89" name="ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89"></a>UCP_ATOMIC_POST_OP_XOR&#160;</td><td class="fielddoc"><p>Atomic xor </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d" name="ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d"></a>UCP_ATOMIC_POST_OP_LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gabd91e0300a53e38d28dbb53dfbb66c55" name="gabd91e0300a53e38d28dbb53dfbb66c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd91e0300a53e38d28dbb53dfbb66c55">&#9670;&#160;</a></span>ucp_atomic_fetch_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> and <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a> instead.</dd></dl>
<p>This enumeration defines which atomic memory operation should be performed by the ucp_atomic_fetch family of functions. All of these functions will fetch data from the remote node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037" name="ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037"></a>UCP_ATOMIC_FETCH_OP_FADD&#160;</td><td class="fielddoc"><p>Atomic Fetch and add <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069" name="ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069"></a>UCP_ATOMIC_FETCH_OP_SWAP&#160;</td><td class="fielddoc"><p>Atomic swap <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c" name="ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c"></a>UCP_ATOMIC_FETCH_OP_CSWAP&#160;</td><td class="fielddoc"><p>Atomic conditional swap </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3" name="ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3"></a>UCP_ATOMIC_FETCH_OP_FAND&#160;</td><td class="fielddoc"><p>Atomic Fetch and and <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59" name="ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59"></a>UCP_ATOMIC_FETCH_OP_FOR&#160;</td><td class="fielddoc"><p>Atomic Fetch and or <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049" name="ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049"></a>UCP_ATOMIC_FETCH_OP_FXOR&#160;</td><td class="fielddoc"><p>Atomic Fetch and xor <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05" name="ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05"></a>UCP_ATOMIC_FETCH_OP_LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafc247802373bbe39e9866745e102a064" name="gafc247802373bbe39e9866745e102a064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc247802373bbe39e9866745e102a064">&#9670;&#160;</a></span>ucp_request_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_request_query </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#structucp__request__attr__t">ucp_request_attr_t</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr</td><td>Filled with attributes of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga4b8ab214f35828ee4608d73442e8c372" name="ga4b8ab214f35828ee4608d73442e8c372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8ab214f35828ee4608d73442e8c372">&#9670;&#160;</a></span>ucp_am_send_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_am_send_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends an Active Message to an ep. If the operation completes immediately, then the routine returns NULL and the callback function is ignored, even if specified. Otherwise, if no error is reported and a callback is requested (i.e. the UCP_OP_ATTR_FIELD_CALLBACK flag is set in the op_attr_mask field of <em>param</em>), then the UCP library will schedule invocation of the callback routine <em>param-&gt;cb.send</em> upon completion of the operation.</p>
<dl class="section note"><dt>Note</dt><dd>If UCP_OP_ATTR_FLAG_NO_IMM_CMPL flag is set in the op_attr_mask field of <em>param</em>, then the operation will return a request handle, even if it completes immediately. </dd>
<dd>
This operation supports specific flags, which can be passed in <em>param</em> by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a55a8ff2559470c5def6077a86ee9d898">ucp_request_param_t::flags</a>. The exact set of flags is defined by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga583228e89cd5c882025ed04c76106aa6">ucp_send_am_flags</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint where the Active Message will be run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Active Message id. Specifies which registered callback to run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>User defined Active Message header. NULL value is allowed if no header needed. In this case <em>header_length</em> must be set to 0. By default the header must be valid until the active message send operation completes. If the flag <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga583228e89cd5c882025ed04c76106aa6a0654f3da5be1bc517d45307b6a21cbdf">UCP_AM_SEND_FLAG_COPY_HEADER</a> is specified, the header is only required to be valid until this function call returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header_length</td><td>Active message header length in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the data to be sent to the target node of the Active Message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending only header without actual data is allowed and is recommended for transferring a latency-critical amount of data. </dd>
<dd>
The maximum allowed header size can be obtained by querying worker attributes by the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query</a> routine.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - Active Message was sent immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - Error sending Active Message. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed at any point in time. The request handle is returned to the application in order to track progress of the message. If user request was not provided in <em>param-&gt;request</em>, the application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a49">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaefaaa5e0a154efe496ae5bb7f2bf71f3" name="gaefaaa5e0a154efe496ae5bb7f2bf71f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefaaa5e0a154efe496ae5bb7f2bf71f3">&#9670;&#160;</a></span>ucp_am_recv_data_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_am_recv_data_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the data descriptor <em>data_desc</em>, local address <em>buffer</em>, size <em>count</em> and <em>param</em> parameters on the <em>worker</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. If the receive operation cannot be started the routine returns an error.</p>
<dl class="section note"><dt>Note</dt><dd>This routine can be performed on any valid data descriptor delivered in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a>. Data descriptor is considered to be valid if:<ul>
<li>It is a rendezvous request (<em>UCP_AM_RECV_ATTR_FLAG_RNDV</em> is set in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#a53a8777a31faf7e65289bcc1d710fb19">ucp_am_recv_param_t::recv_attr</a>) or</li>
<li>It is a persistent data pointer (<em>UCP_AM_RECV_ATTR_FLAG_DATA</em> is set in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#a53a8777a31faf7e65289bcc1d710fb19">ucp_am_recv_param_t::recv_attr</a>). In this case receive operation may be needed to unpack data to device memory (for example GPU device) or some specific datatype. </li>
</ul>
</dd>
<dd>
After this call UCP takes ownership of <em>data_desc</em> descriptor, so there is no need to release it even if the operation fails. The routine returns a request handle instead, which can be used for tracking operation progress.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_desc</td><td>Data descriptor, provided in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gab3adc96222b05543c6cba8c28c16703b">ucp_am_recv_callback_t</a> routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. In this case, if <em>param-&gt;recv_info.length</em> is specified in the <em>param</em>, the value to which it points is updated with the size of the received message. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Receive operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track operation progress. If user request was not provided in <em>param-&gt;request</em>, the application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a47">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga45570903fc3ce01e7e5c0cd241f516f9" name="ga45570903fc3ce01e7e5c0cd241f516f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45570903fc3ce01e7e5c0cd241f516f9">&#9670;&#160;</a></span>ucp_am_data_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_am_data_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine releases data that persisted through an Active Message callback because that callback returned UCS_INPROGRESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker which received the Active Message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to data that was passed into the Active Message callback as the data parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9fe6efe6b05e4e78f58bee68c68b252" name="gae9fe6efe6b05e4e78f58bee68c68b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9fe6efe6b05e4e78f58bee68c68b252">&#9670;&#160;</a></span>ucp_stream_send_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_send_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends data that is described by the local address <em>buffer</em>, size <em>count</em> object to the destination endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed at any point in time. The request handle is returned to the application in order to track progress of the message. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a35">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga8323878b60f426c630d4ff8996ede3cc" name="ga8323878b60f426c630d4ff8996ede3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8323878b60f426c630d4ff8996ede3cc">&#9670;&#160;</a></span>ucp_tag_send_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">receiver</a>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK and the call-back function is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported then the UCP library will schedule to invoke the call-back whenever the send operation is completed. In other words, the completion of a message can be signaled by the return code or the call-back. Immediate completion signals can be fine-tuned via the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a97e9444548efb351db6a07130fb69c28">ucp_request_param_t::op_attr_mask</a> field in the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> structure. The values of this field are a bit-wise OR of the <a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a> enumeration.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a40">ucp_client_server.c</a>, and <a class="el" href="ucp_hello_world_8c-example.html#a31">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga0d96a2aac42fe99ce0c79f15dda8bd06" name="ga0d96a2aac42fe99ce0c79f15dda8bd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d96a2aac42fe99ce0c79f15dda8bd06">&#9670;&#160;</a></span>ucp_tag_send_sync_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_sync_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a>, except the request completes only after there is a remote tag match on the message (which does not always mean the remote receive has been completed). This function never completes "in-place", and always returns a request handle.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes. </dd>
<dd>
Returns <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a252c38290855ceaf849c04b7fa52dc23">UCS_ERR_UNSUPPORTED</a> if <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gga7c69a28724d5ae3e49490e23e64df167aa31630259732e700b6ce0fe612cf0a6f">UCP_ERR_HANDLING_MODE_PEER</a> is enabled. This is a temporary implementation-related constraint that will be addressed in future releases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. </dd></dl>

</div>
</div>
<a id="ga30494ce33e63823c81c2c5b3656d25c3" name="ga30494ce33e63823c81c2c5b3656d25c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30494ce33e63823c81c2c5b3656d25c3">&#9670;&#160;</a></span>ucp_stream_recv_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives data that is described by the local address <em>buffer</em>, size <em>count</em> object on the endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered complete when the message is delivered to the buffer. If the receive operation cannot be started, then the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer that will receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Size of the received data in bytes. The value is valid only if return code is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>. This operation supports specific flags, which can be passed in <em>param</em> by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a55a8ff2559470c5def6077a86ee9d898">ucp_request_param_t::flags</a>. The exact set of flags is defined by <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. In this case the value pointed by <em>length</em> is updated by the size of received data. Note <em>param-&gt;recv_info</em> is not relevant for this function. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. A request handle is returned to the application in order to track progress of the operation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The amount of data received, in bytes, is always an integral multiple of the <em>datatype</em> size. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a39">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga47f307f4765eb5410f24ac27986b59d7" name="ga47f307f4765eb5410f24ac27986b59d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f307f4765eb5410f24ac27986b59d7">&#9670;&#160;</a></span>ucp_stream_recv_data_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_data_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives any available data from endpoint <em>ep</em>. Unlike <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a>, the returned data is unstructured and is treated as an array of bytes. If data is immediately available, UCS_STATUS_PTR(_ptr) is returned as a pointer to the data, and <em>length</em> is set to the size of the returned data buffer. The routine is non-blocking and therefore returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Length of received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - No received data available on the <em>ep</em>. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - the receive operation failed and UCS_PTR_STATUS(_ptr) indicates an error. </dd>
<dd>
otherwise - The pointer to the data UCS_STATUS_PTR(_ptr) is returned to the application. After the data is processed, the application is responsible for releasing the data buffer by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga1d1c1c1b2caf4f26c9872e1d708d5f68">ucp_stream_data_release</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns packed data (equivalent to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a>). </dd>
<dd>
This function returns a pointer to a UCP-supplied buffer, whereas <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> places the data into a user-provided buffer. In some cases, receiving data directly into a UCP-supplied buffer can be more optimal, for example by processing the incoming data in-place and thus avoiding extra memory copy operations. </dd></dl>

</div>
</div>
<a id="gaa842f8ca8ad1363ed857ab938285a16f" name="gaa842f8ca8ad1363ed857ab938285a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa842f8ca8ad1363ed857ab938285a16f">&#9670;&#160;</a></span>ucp_tag_recv_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_recv_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>info</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The routine is a non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be started, then the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. In this case, if <em>param-&gt;recv_info.tag_info</em> is specified in the <em>param</em>, the value to which it points is updated with the information about the received message. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a41">ucp_client_server.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga41668f468dc37a7634116b8210815f22" name="ga41668f468dc37a7634116b8210815f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41668f468dc37a7634116b8210815f22">&#9670;&#160;</a></span>ucp_tag_probe_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> ucp_tag_probe_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine probes (checks) if a messages described by the <em>tag</em> and <em>tag_mask</em> was received (fully or partially) on the <em>worker</em>. The tag value of the received message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The function returns immediately and if the message is matched it returns a handle for the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the probe operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to probe for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove</td><td>The flag indicates if the matched message has to be removed from UCP library. If true (1), the message handle is removed from the UCP library and the application is responsible to call <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a> in order to receive the data and release the resources associated with the message handle. If false (0), the return value is merely an indication to whether a matching message is present, and it cannot be used in any other way, and in particular it cannot be passed to <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>If the matching message is found the descriptor is filled with the details about the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - No match found. </dd>
<dd>
Message handle (not NULL) - If message is matched the message handle is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not advance the communication state of the network. If this routine is used in busy-poll mode, need to make sure <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress()</a> is called periodically to extract messages from the transport. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a32">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga48c61d44f18362bdaf8fca3122efcea6" name="ga48c61d44f18362bdaf8fca3122efcea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c61d44f18362bdaf8fca3122efcea6">&#9670;&#160;</a></span>ucp_tag_msg_recv_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_msg_recv_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>message</em> handle on the <em>worker</em>. The <em>message</em> handle can be obtained by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb()</a> routine. The <a class="el" href="group___u_c_p___c_o_m_m.html#ga48c61d44f18362bdaf8fca3122efcea6">ucp_tag_msg_recv_nbx()</a> routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be started, then the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer that will receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a38">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga29e7b9b70b782140e63544b8613a5fe7" name="ga29e7b9b70b782140e63544b8613a5fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e7b9b70b782140e63544b8613a5fe7">&#9670;&#160;</a></span>ucp_put_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_put_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> rkey. The routine returns immediately and <b>does</b> <b>not</b> guarantee re-usability of the source address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the put operation completes immediately, the routine returns UCS_OK and the call-back routine <em>param.cb.send</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>param.cb.send</em> upon completion of the put operation. In other words, the completion of a put operation can be signaled by the return code or execution of the call-back. Immediate completion signals can be fine-tuned via the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a97e9444548efb351db6a07130fb69c28">ucp_request_param_t::op_attr_mask</a> field in the <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> structure. The values of this field are a bit-wise OR of the <a class="el" href="group___u_c_p___c_o_m_m.html#ga67fae646dd1668efba6efe49a35a6610">ucp_op_attr_t</a> enumeration.</p>
<dl class="section note"><dt>Note</dt><dd>The completion of a put operation signals the local <em>buffer</em> can be reused. The completion of the operation on the remote address requires use of <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga57fedddf88d4b777f5c16b39b5fcf52e">ucp_worker_flush_nbx()</a> or <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga28d61bf53320bd0f5d741147447251a4">ucp_ep_flush_nbx()</a>, after completion of which the data in <em>remote_addr</em> is guaranteed to be available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements of type <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> to put. If <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> is not specified, the type defaults to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a>, which corresponds to byte elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only the datatype <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a> is supported for <em>param-&gt;datatype</em>, see <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5">ucp_dt_make_contig</a>. </dd></dl>

</div>
</div>
<a id="gaa06c6521592661a8123c11426074d880" name="gaa06c6521592661a8123c11426074d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa06c6521592661a8123c11426074d880">&#9670;&#160;</a></span>ucp_get_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_get_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a load of a contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the get operation completes immediately, the routine returns UCS_OK and the call-back routine <em>param.cb.send</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>param.cb.send</em> upon completion of the get operation. In other words, the completion of a get operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>. </dd>
<dd>
The completion of a get operation signals the local <em>buffer</em> holds the the expected data and that both local <em>buffer</em> and remote <em>remote_addr</em> are safe to be reused, unlike with <a class="el" href="group___u_c_p___c_o_m_m.html#ga29e7b9b70b782140e63544b8613a5fe7">ucp_put_nbx</a> where the use of <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga57fedddf88d4b777f5c16b39b5fcf52e">ucp_worker_flush_nbx()</a> or <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga28d61bf53320bd0f5d741147447251a4">ucp_ep_flush_nbx()</a> is required before the remote data is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements of type <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> to put. If <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> is not specified, the type defaults to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a>, which corresponds to byte elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the source remote memory address to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only the datatype <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(1)</a> is supported for <em>param-&gt;datatype</em>, see <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5">ucp_dt_make_contig</a>. </dd></dl>

</div>
</div>
<a id="ga087e2cad02e84cf1230684362562aa46" name="ga087e2cad02e84cf1230684362562aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga087e2cad02e84cf1230684362562aa46">&#9670;&#160;</a></span>ucp_atomic_op_nbx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_atomic_op_nbx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine will post an atomic operation to remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The routine is non-blocking and therefore returns immediately. However, the actual atomic operation may be delayed. In order to enable fetching semantics for atomic operations user has to specify <em>param.reply_buffer</em>. Please see <a class="el" href="group___u_c_p___c_o_m_m.html#atomic_ops">table</a> below for more details.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> (or also <em>param-&gt;reply_buffer</em> for fetch operations), until the operation completes. </dd>
<dd>
Only ucp_dt_make_config(4) and <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type.">ucp_dt_make_contig(8)</a> are supported in <em>param-&gt;datatype</em>, see <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5">ucp_dt_make_contig</a>. Also, currently atomic operations can handle one element only. Thus, <em>count</em> argument must be set to 1.</dd></dl>
<a class="anchor" id="atomic_ops"></a>
<table class="doxtable">
<caption>Atomic Operations Semantic</caption>
<tr>
<th align="center">Atomic Operation </th><th align="center">Pseudo code </th><th align="center">X </th><th align="center">Y </th><th align="center">Z </th><th align="center">Result </th></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380a9386a4cc004f74e89bb069096ff1e43b">UCP_ATOMIC_OP_ADD</a> </td><td align="left">Result=Y; Y+=X </td><td align="left">buffer</td><td align="left">remote_addr</td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380af72a4149b8c55e187bdfdcbd8d201eeb">UCP_ATOMIC_OP_SWAP</a> </td><td align="left">Result=Y; Y=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ae5da2927554be21b16aa65f9e46f762a">UCP_ATOMIC_OP_CSWAP</a> </td><td align="left">Result=Y; if (X==Y) then Y=Z</td><td align="left">buffer </td><td align="left">remote_addr </td><td align="left">param.reply_buffer </td><td align="left">param.reply_buffer </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380adf96b275090535fca4d7c1bedaef7da3">UCP_ATOMIC_OP_AND</a> </td><td align="left">Result=Y; Y&amp;=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380abf085a4df55bbd6109e3fb849e0d123e">UCP_ATOMIC_OP_OR</a> </td><td align="left">Result=Y; Y|=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
<tr>
<td align="left"><a class="el" href="group___u_c_p___c_o_m_m.html#gga5c2ee7516e48146c044e3d9e2a2ed380ac723509b3a97de7b43d1736bf9d79243">UCP_ATOMIC_OP_XOR</a> </td><td align="left">Result=Y; Y^=X </td><td align="left">buffer</td><td align="left">remote_addr </td><td align="center">- </td><td align="left">param.reply_buffer(optional) </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#ga5c2ee7516e48146c044e3d9e2a2ed380">ucp_atomic_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Address of operand for the atomic operation. See <a class="el" href="group___u_c_p___c_o_m_m.html#atomic_ops">Atomic Operations Semantic table</a> for exact usage by different atomic operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements in <em>buffer</em> and <em>result</em>. The size of each element is specified by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#a3988d603154f90eb5405785cac62b65f">ucp_request_param_t::datatype</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Operation parameters, see <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#structucp__request__param__t">ucp_request_param_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at some time in the future. The request handle is returned to the application in order to track progress of the operation. </dd></dl>

</div>
</div>
<a id="gae082ad7af428645ebe6e469d3d06a757" name="gae082ad7af428645ebe6e469d3d06a757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae082ad7af428645ebe6e469d3d06a757">&#9670;&#160;</a></span>ucp_request_check_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_request_check_status </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state of the request and returns its current status. Any value different from UCS_INPROGRESS means that request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a23">ucp_client_server.c</a>, and <a class="el" href="ucp_hello_world_8c-example.html#a4">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga707cbbef8cdcf90fa7cf63c922ef2c7f" name="ga707cbbef8cdcf90fa7cf63c922ef2c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707cbbef8cdcf90fa7cf63c922ef2c7f">&#9670;&#160;</a></span>ucp_tag_recv_request_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_recv_request_test </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state and returns current status of the request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> routine or the user allocated request for <a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">ucp_tag_recv_nbr</a>. Any value different from UCS_INPROGRESS means that the request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>It is filled with the details about the message available at the moment of calling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga4d8d8823b24cb25dcab8bf44c72fa25e" name="ga4d8d8823b24cb25dcab8bf44c72fa25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8d8823b24cb25dcab8bf44c72fa25e">&#9670;&#160;</a></span>ucp_stream_recv_request_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_stream_recv_request_test </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state and returns current status of the request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> routine. Any value different from UCS_INPROGRESS means that the request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length_p</td><td>The size of the received data in bytes. This value is only valid if the status is UCS_OK. If valid, it is always an integral multiple of the datatype size associated with the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga3553f89a61d6b40af4633a2e7c84fc1d" name="ga3553f89a61d6b40af4633a2e7c84fc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3553f89a61d6b40af4633a2e7c84fc1d">&#9670;&#160;</a></span>ucp_request_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_request_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to cancel.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine tries to cancels an outstanding communication request. After calling this routine, the <em>request</em> will be in completed or canceled (but not both) state regardless of the status of the target endpoint associated with the communication request. If the request is completed successfully, the <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">send</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">receive</a> completion callbacks (based on the type of the request) will be called with the <em>status</em> argument of the callback set to UCS_OK, and in a case it is canceled the <em>status</em> argument is set to UCS_ERR_CANCELED. It is important to note that in order to release the request back to the library the application is responsible for calling <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a>. </p>

</div>
</div>
<a id="ga1d1c1c1b2caf4f26c9872e1d708d5f68" name="ga1d1c1c1b2caf4f26c9872e1d708d5f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d1c1c1b2caf4f26c9872e1d708d5f68">&#9670;&#160;</a></span>ucp_stream_data_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_stream_data_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint <em>data</em> received from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data pointer to release, which was returned from <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases internal UCP data buffer returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a> when <em>data</em> is processed, the application can't use this buffer after calling this function. </p>

</div>
</div>
<a id="ga0e8e46f5953d464382b21edef3ec9994" name="ga0e8e46f5953d464382b21edef3ec9994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8e46f5953d464382b21edef3ec9994">&#9670;&#160;</a></span>ucp_request_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_request_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases the non-blocking request back to the library, regardless of its current state. Communications operations associated with this request will make progress internally, however no further notifications or callbacks will be invoked for this request. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_client_server_8c-example.html#a24">ucp_client_server.c</a>, and <a class="el" href="ucp_hello_world_8c-example.html#a5">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga896e6f781c5fb026a6e25b0151bdb745" name="ga896e6f781c5fb026a6e25b0151bdb745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896e6f781c5fb026a6e25b0151bdb745">&#9670;&#160;</a></span>ucp_request_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ucp_request_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a></dd></dl>
<p>This routine creates request which may be used in functions <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a>, <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a>, etc. The application is responsible for releasing the handle using the <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine </p>

</div>
</div>
<a id="ga432e478b97575b21855074a45d54520d" name="ga432e478b97575b21855074a45d54520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432e478b97575b21855074a45d54520d">&#9670;&#160;</a></span>ucp_request_is_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ucp_request_is_completed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga3802a983138ed27034b7d52026dccb2f">ucp_request_test</a>. </dd></dl>

</div>
</div>
<a id="ga85b0a27cf8a3239decabad6a9104eb31" name="ga85b0a27cf8a3239decabad6a9104eb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85b0a27cf8a3239decabad6a9104eb31">&#9670;&#160;</a></span>ucp_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a>. The following example implements the same functionality using <a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a> : </dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> empty_callback(<span class="keywordtype">void</span> *request, <a class="code hl_enumeration" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumeration" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> put(<a class="code hl_typedef" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <span class="keyword">const</span> <span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> length,</div>
<div class="line">                  uint64_t remote_addr, <a class="code hl_typedef" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> *request = <a class="code hl_function" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a>(ep, buffer, length, remote_addr, rkey,</div>
<div class="line">                               empty_callback),</div>
<div class="line">    <span class="keywordflow">if</span> (request == NULL) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a">UCS_OK</a>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (UCS_PTR_IS_ERR(request)) {</div>
<div class="line">        <span class="keywordflow">return</span> UCS_PTR_STATUS(request);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <a class="code hl_enumeration" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status;</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            <a class="code hl_function" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a>(worker);</div>
<div class="line">            status = <a class="code hl_function" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a>(request);</div>
<div class="line">        } <span class="keywordflow">while</span> (status == <a class="code hl_enumvalue" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a>);</div>
<div class="line">        <a class="code hl_function" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gaabf569a298946627fbc8d66814c35e68">ucp_request_release</a>(request);</div>
<div class="line">        <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup___u_c_p___c_o_m_m_html_ga1ba986b2bde69c215abd5766dbceeb18"><div class="ttname"><a href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a></div><div class="ttdeci">ucs_status_ptr_t ucp_put_nb(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)</div><div class="ttdoc">Non-blocking remote memory put operation.</div></div>
<div class="ttc" id="agroup___u_c_p___c_o_m_m_html_gae082ad7af428645ebe6e469d3d06a757"><div class="ttname"><a href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a></div><div class="ttdeci">ucs_status_t ucp_request_check_status(void *request)</div><div class="ttdoc">Check the status of non-blocking request.</div></div>
<div class="ttc" id="agroup___u_c_p___e_n_d_p_o_i_n_t_html_ga9bea4e4174ea25f44285d8e7a9fb7adf"><div class="ttname"><a href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a></div><div class="ttdeci">struct ucp_ep * ucp_ep_h</div><div class="ttdoc">UCP Endpoint.</div><div class="ttdef"><b>Definition</b> ucp_def.h:92</div></div>
<div class="ttc" id="agroup___u_c_p___e_n_d_p_o_i_n_t_html_gaabf569a298946627fbc8d66814c35e68"><div class="ttname"><a href="group___u_c_p___e_n_d_p_o_i_n_t.html#gaabf569a298946627fbc8d66814c35e68">ucp_request_release</a></div><div class="ttdeci">void ucp_request_release(void *request)</div></div>
<div class="ttc" id="agroup___u_c_p___m_e_m_html_gaefeb4e775983f4313691a6b465e36c24"><div class="ttname"><a href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a></div><div class="ttdeci">struct ucp_rkey * ucp_rkey_h</div><div class="ttdoc">UCP Remote memory handle.</div><div class="ttdef"><b>Definition</b> ucp_def.h:152</div></div>
<div class="ttc" id="agroup___u_c_p___w_o_r_k_e_r_html_ga340784a8528d4932916651460dc481c0"><div class="ttname"><a href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a></div><div class="ttdeci">unsigned ucp_worker_progress(ucp_worker_h worker)</div><div class="ttdoc">Progress all communications on a specific worker.</div></div>
<div class="ttc" id="agroup___u_c_s___r_e_s_o_u_r_c_e_html_ga88ca72d7294772e7d2edb70a2df15558"><div class="ttname"><a href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a></div><div class="ttdeci">ucs_status_t</div><div class="ttdoc">Status codes.</div><div class="ttdef"><b>Definition</b> status.h:45</div></div>
<div class="ttc" id="agroup___u_c_s___r_e_s_o_u_r_c_e_html_gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a"><div class="ttname"><a href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a">UCS_OK</a></div><div class="ttdeci">@ UCS_OK</div><div class="ttdef"><b>Definition</b> status.h:47</div></div>
<div class="ttc" id="agroup___u_c_s___r_e_s_o_u_r_c_e_html_gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a"><div class="ttname"><a href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a></div><div class="ttdeci">@ UCS_INPROGRESS</div><div class="ttdef"><b>Definition</b> status.h:50</div></div>
</div><!-- fragment --><p>This routine stores contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em>. The routine returns when it is safe to reuse the source address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaf4a465cff6c1691106430564899f6f3e" name="gaf4a465cff6c1691106430564899f6f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a465cff6c1691106430564899f6f3e">&#9670;&#160;</a></span>ucp_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga7cb68811f53a69d37fd16e8ddb46e23b">ucp_get_nb</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine loads contiguous block of data that is described by the remote address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns when remote data is loaded and stored under the local address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa042d7e76314e1d7ea9717d4adacde7b" name="gaa042d7e76314e1d7ea9717d4adacde7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa042d7e76314e1d7ea9717d4adacde7b">&#9670;&#160;</a></span>ucp_atomic_add32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_add32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> with opcode UCP_ATOMIC_POST_OP_ADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 32 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes the sum of the original remote value and the operand value (<em>add</em>) is stored in remote memory. The call to the routine returns immediately, independent of operation completion.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa80cd3f104b920c0c2f6bf7cff50fc15" name="gaa80cd3f104b920c0c2f6bf7cff50fc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80cd3f104b920c0c2f6bf7cff50fc15">&#9670;&#160;</a></span>ucp_atomic_add64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_add64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> with opcode UCP_ATOMIC_POST_OP_ADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 64 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes the sum of the original remote value and the operand value (<em>add</em>) is stored in remote memory. The call to the routine returns immediately, independent of operation completion.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga0c777d7d1c59e01151ef5e3fcd7e5b94" name="ga0c777d7d1c59e01151ef5e3fcd7e5b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c777d7d1c59e01151ef5e3fcd7e5b94">&#9670;&#160;</a></span>ucp_atomic_fadd32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_fadd32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_FADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 32 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes, the original remote value is stored in the local memory <em>result</em>, and the sum of the original remote value and the operand value is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga7435bc5d5e2c4fb6b491d457ab65596b" name="ga7435bc5d5e2c4fb6b491d457ab65596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7435bc5d5e2c4fb6b491d457ab65596b">&#9670;&#160;</a></span>ucp_atomic_fadd64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_fadd64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_FADD. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine performs an add operation on a 64 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes, the original remote value is stored in the local memory <em>result</em>, and the sum of the original remote value and the operand value is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga43118f9d5e6d8fdfa518887218468bb3" name="ga43118f9d5e6d8fdfa518887218468bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43118f9d5e6d8fdfa518887218468bb3">&#9670;&#160;</a></span>ucp_atomic_swap32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_swap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_SWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine swaps a 32 bit value between local and remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>swap</em> value is the value that is used for the swap operation. When the operation completes, the remote value is stored in the local memory <em>result</em>, and the operand value (<em>swap</em>) is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gaa2913e345505195a183ccc2583fb4ebc" name="gaa2913e345505195a183ccc2583fb4ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2913e345505195a183ccc2583fb4ebc">&#9670;&#160;</a></span>ucp_atomic_swap64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_swap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_SWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine swaps a 64 bit value between local and remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>swap</em> value is the value that is used for the swap operation. When the operation completes, the remote value is stored in the local memory <em>result</em>, and the operand value (<em>swap</em>) is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga6078dddaa93c8dfdab3c18014064f0c0" name="ga6078dddaa93c8dfdab3c18014064f0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6078dddaa93c8dfdab3c18014064f0c0">&#9670;&#160;</a></span>ucp_atomic_cswap32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_cswap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_CSWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine conditionally swaps a 32 bit value between local and remote memory. The swap occurs only if the condition value (<em>continue</em>) is equal to the remote value, otherwise the remote memory is not modified. The remote value is described by the combination of the remote memory address <code>remote_addr</code> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <code>swap</code> value is the value that is used to update the remote memory if the condition is true. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>Value to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gafa365c16d4c2b4fd2aba6e94fec2c92b" name="gafa365c16d4c2b4fd2aba6e94fec2c92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa365c16d4c2b4fd2aba6e94fec2c92b">&#9670;&#160;</a></span>ucp_atomic_cswap64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_cswap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_CSWAP. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation.">ucp_put</a>.</dd></dl>
<p>This routine conditionally swaps a 64 bit value between local and remote memory. The swap occurs only if the condition value (<em>continue</em>) is equal to the remote value, otherwise the remote memory is not modified. The remote value is described by the combination of the remote memory address <code>remote_addr</code> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <code>swap</code> value is the value that is used to update the remote memory if the condition is true. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>Value to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga94ec21811930b6b6fb8eab500b8c730d" name="ga94ec21811930b6b6fb8eab500b8c730d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ec21811930b6b6fb8eab500b8c730d">&#9670;&#160;</a></span>ucp_am_send_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_am_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga4b8ab214f35828ee4608d73442e8c372">ucp_am_send_nbx</a> instead.</dd></dl>
<p>This routine sends an Active Message to an ep. It does not support CUDA memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint where the Active Message will be run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Active Message id. Specifies which registered callback to run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the data to be sent to the target node of the Active Message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback that is invoked upon completion of the data transfer if it is not completed immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Operation flags as defined by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga583228e89cd5c882025ed04c76106aa6">ucp_send_am_flags</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Active Message was sent immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) Error sending Active Message. </dd>
<dd>
otherwise Pointer to request, and Active Message is known to be completed after cb is run. </dd></dl>

</div>
</div>
<a id="ga9022ff0ebb56cac81f6ba81bb28f71b3" name="ga9022ff0ebb56cac81f6ba81bb28f71b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9022ff0ebb56cac81f6ba81bb28f71b3">&#9670;&#160;</a></span>ucp_stream_send_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#gae9fe6efe6b05e4e78f58bee68c68b252">ucp_stream_send_nbx</a> instead.</dd></dl>
<p>This routine sends data that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK and the callback function <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported, then the UCP library will schedule invocation of the callback <em>cb</em> upon completion of the send operation. In other words, the completion of the operation will be signaled either by the return code or by the callback.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed. It is important to note that the callback is only invoked in the event that the operation cannot be completed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Reserved for future use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>

</div>
</div>
<a id="gadf3b4504a329a46d2d4ec0a8cec08130" name="gadf3b4504a329a46d2d4ec0a8cec08130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3b4504a329a46d2d4ec0a8cec08130">&#9670;&#160;</a></span>ucp_stream_recv_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga30494ce33e63823c81c2c5b3656d25c3">ucp_stream_recv_nbx</a> instead.</dd></dl>
<p>This routine receives data that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered complete when the message is delivered to the buffer. If data is not immediately available, the operation will be scheduled for receive and a request handle will be returned. In order to notify the application about completion of a scheduled receive operation, the UCP library will invoke the call-back <em>cb</em> when data is in the receive buffer and ready for application access. If the receive operation cannot be started, the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>. It is important to note that the call-back is only invoked in a case when the operation cannot be completed immediately. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Size of the received data in bytes. The value is valid only if return code is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The amount of data received, in bytes, is always an integral multiple of the <em>datatype</em> size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags defined in <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The receive operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. A request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>

</div>
</div>
<a id="gaae7343bd638924e5518041311d5c1dfc" name="gaae7343bd638924e5518041311d5c1dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7343bd638924e5518041311d5c1dfc">&#9670;&#160;</a></span>ucp_tag_send_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a> instead.</dd></dl>
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">receiver</a>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine return UCS_OK and the call-back function <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported then the UCP library will schedule to invoke the call-back <em>cb</em> whenever the send operation will be completed. In other words, the completion of a message can be signaled by the return code or the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="gad90aa964e14fef59b4e3bd9120cca669" name="gad90aa964e14fef59b4e3bd9120cca669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad90aa964e14fef59b4e3bd9120cca669">&#9670;&#160;</a></span>ucp_tag_send_nbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_send_nbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga8323878b60f426c630d4ff8996ede3cc">ucp_tag_send_nbx</a> with the flag <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996">UCP_OP_ATTR_FIELD_REQUEST</a> instead.</dd></dl>
<p>This routine provides a convenient and efficient way to implement a blocking send pattern. It also completes requests faster than <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb()</a> because: </p><ul>
<li>it always uses eager protocol to send data up to the rendezvous threshold. </li>
<li>its rendezvous threshold is higher than the one used by the <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb()</a>. The threshold is controlled by the <b>UCX_SEND_NBR_RNDV_THRESH</b> environment variable. </li>
<li>its request handling is simpler. There is no callback and no need to allocate and free requests. In fact request can be allocated by caller on the stack.</li>
</ul>
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">receiver</a>.</p>
<p>The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK.</p>
<p>If the operation is <b>not</b> completed immediately and no error reported then the UCP library will fill a user provided <em>req</em> and return UCS_INPROGRESS status. In order to monitor completion of the operation <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status()</a> should be used.</p>
<p>Following pseudo code implements a blocking send function: </p><div class="fragment"><div class="line">MPI_send(...)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> *request;</div>
<div class="line">    <a class="code hl_enumeration" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// allocate request on the stack</span></div>
<div class="line">    <span class="comment">// ucp_context_query() was used to get ucp_request_size</span></div>
<div class="line">    request = alloca(ucp_request_size);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// note: make sure that there is enough memory before the</span></div>
<div class="line">    <span class="comment">// request handle</span></div>
<div class="line">    status = <a class="code hl_function" href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr</a>(ep, ..., request + ucp_request_size);</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code hl_enumvalue" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <a class="code hl_function" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a>(worker);</div>
<div class="line">        status = <a class="code hl_function" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a>(request + ucp_request_size);</div>
<div class="line">    } <span class="keywordflow">while</span> (status == <a class="code hl_enumvalue" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a77aa02620851779729e4ad6ceb41f84a">UCS_INPROGRESS</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="ttc" id="agroup___u_c_p___c_o_m_m_html_gad90aa964e14fef59b4e3bd9120cca669"><div class="ttname"><a href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr</a></div><div class="ttdeci">ucs_status_t ucp_tag_send_nbr(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, void *req)</div><div class="ttdoc">Non-blocking tagged-send operations with user provided request.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle allocated by the user. There should be at least UCP request size bytes of available space before the <em>req</em>. The size of UCP request can be obtained by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga3485fb61663f4cc6f32e801654aedcff">ucp_context_query</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_INPROGRESS - The send was not completed and is in progress. <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status()</a> should be used to monitor <em>req</em> status. </dd>
<dd>
Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gabd3e1ccae2ef34463e8313d09d3db17f" name="gabd3e1ccae2ef34463e8313d09d3db17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd3e1ccae2ef34463e8313d09d3db17f">&#9670;&#160;</a></span>ucp_tag_send_sync_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_sync_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga0d96a2aac42fe99ce0c79f15dda8bd06">ucp_tag_send_sync_nbx</a> instead.</dd></dl>
<p>Same as <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb</a>, except the request completes only after there is a remote tag match on the message (which does not always mean the remote receive has been completed). This function never completes "in-place", and always returns a request handle.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes. </dd>
<dd>
Returns <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a252c38290855ceaf849c04b7fa52dc23">UCS_ERR_UNSUPPORTED</a> if <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gga7c69a28724d5ae3e49490e23e64df167aa31630259732e700b6ce0fe612cf0a6f">UCP_ERR_HANDLING_MODE_PEER</a> is enabled. This is a temporary implementation-related constraint that will be addressed in future releases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="gaeb24cdfc33dfb2886551b51843aa6304" name="gaeb24cdfc33dfb2886551b51843aa6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb24cdfc33dfb2886551b51843aa6304">&#9670;&#160;</a></span>ucp_tag_recv_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a> instead.</dd></dl>
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates which bits of the tag have to be matched. The routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be stated the routine returns an error.</p>
<dl class="section note"><dt>Note</dt><dd>This routine cannot return UCS_OK. It always returns a request handle or an error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga5a86663a4a144fd81d7a4e3378c5edd2" name="ga5a86663a4a144fd81d7a4e3378c5edd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a86663a4a144fd81d7a4e3378c5edd2">&#9670;&#160;</a></span>ucp_tag_recv_nbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_recv_nbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a> with the flag <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610acfac7dfc3e7b5967870f5376c334b996">UCP_OP_ATTR_FIELD_REQUEST</a> instead.</dd></dl>
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates which bits of the tag have to be matched. The routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to monitor completion of the operation <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#ga707cbbef8cdcf90fa7cf63c922ef2c7f">ucp_tag_recv_request_test</a> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle allocated by the user. There should be at least UCP request size bytes of available space before the <em>req</em>. The size of UCP request can be obtained by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga3485fb61663f4cc6f32e801654aedcff">ucp_context_query</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="gac335b3ae4c9577728d9c0f2ecd44c084" name="gac335b3ae4c9577728d9c0f2ecd44c084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac335b3ae4c9577728d9c0f2ecd44c084">&#9670;&#160;</a></span>ucp_tag_msg_recv_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_msg_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#gaa842f8ca8ad1363ed857ab938285a16f">ucp_tag_recv_nbx</a> instead.</dd></dl>
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, <em>message</em> handle, and <em>datatype</em> object on the <em>worker</em>. The <em>message</em> handle can be obtained by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb()</a> routine. The <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a> routine is non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be started the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer that will receive the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga77f3d5def7a77c4ba88f9e1eefa4b7e6" name="ga77f3d5def7a77c4ba88f9e1eefa4b7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">&#9670;&#160;</a></span>ucp_put_nbi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_put_nbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga29e7b9b70b782140e63544b8613a5fe7">ucp_put_nbx</a> without passing the flag <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602">UCP_OP_ATTR_FIELD_CALLBACK</a> instead. If a request pointer is returned, release it immediately by <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a>.</dd></dl>
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" @a rkey. The routine returns immediately and @b does @b not
guarantee re-usability of the source address @e buffer. If the operation is
completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS
or an error is returned to user.

@note A user can use @ref ucp_worker_flush_nb "<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847" title="Flush outstanding AMO and RMA operations on the worker.">ucp_worker_flush_nb()</a>" in order to guarantee re-usability of the source address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga1ba986b2bde69c215abd5766dbceeb18" name="ga1ba986b2bde69c215abd5766dbceeb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba986b2bde69c215abd5766dbceeb18">&#9670;&#160;</a></span>ucp_put_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_put_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga29e7b9b70b782140e63544b8613a5fe7">ucp_put_nbx</a> instead.</dd></dl>
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" @a rkey.  The routine returns immediately and @b does @b not
guarantee re-usability of the source address @e buffer. If the operation is
completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS
or an error is returned to user. If the put operation completes immediately,
the routine returns UCS_OK and the call-back routine @a cb is @b not
invoked. If the operation is @b not completed immediately and no error is
reported, then the UCP library will schedule invocation of the call-back
routine @a cb upon completion of the put operation. In other words, the
completion of a put operation can be signaled by the return code or
execution of the call-back.

@note A user can use @ref ucp_worker_flush_nb "<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847" title="Flush outstanding AMO and RMA operations on the worker.">ucp_worker_flush_nb()</a>"
in order to guarantee re-usability of the source address @e buffer.

@param [in]  ep           Remote endpoint handle.
@param [in]  buffer       Pointer to the local source address.
@param [in]  length       Length of the data (in bytes) stored under the
                          source address.
@param [in]  remote_addr  Pointer to the destination remote memory address
                          to write to.
@param [in]  rkey         Remote memory key associated with the
                          remote memory address.
@param [in]  cb           Call-back function that is invoked whenever the
                          put operation is completed and the local buffer
                          can be modified. Does not guarantee remote
                          completion.

@return NULL                 - The operation was completed immediately.
@return UCS_PTR_IS_ERR(_ptr) - The operation failed.
@return otherwise            - Operation was scheduled and can be
                             completed at any point in time. The request handle
                             is returned to the application in order to track
                             progress of the operation. The application is
                             responsible for releasing the handle using
                             @ref ucp_request_free "<a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994" title="Release a communications request.">ucp_request_free()</a>" routine. </p>

</div>
</div>
<a id="gae3597f699227d598651f6630fbd7968b" name="gae3597f699227d598651f6630fbd7968b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3597f699227d598651f6630fbd7968b">&#9670;&#160;</a></span>ucp_get_nbi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_get_nbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#gaa06c6521592661a8123c11426074d880">ucp_get_nbx</a> without passing the flag <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a73e3a6e8b96b37ec1b0764e67dd13602">UCP_OP_ATTR_FIELD_CALLBACK</a> instead. If a request pointer is returned, release it immediately by <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a>.</dd></dl>
<p>This routine initiate a load of contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order guarantee that remote data is loaded and stored under the local address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the source remote memory address to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga7cb68811f53a69d37fd16e8ddb46e23b" name="ga7cb68811f53a69d37fd16e8ddb46e23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb68811f53a69d37fd16e8ddb46e23b">&#9670;&#160;</a></span>ucp_get_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_get_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#gaa06c6521592661a8123c11426074d880">ucp_get_nbx</a> instead.</dd></dl>
<p>This routine initiates a load of a contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the get operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the get operation. In other words, the completion of a get operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the destination address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the source remote memory address to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the get operation is completed and the data is visible to the local process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a id="ga839312fb4de5e786daacb4fa071d61df" name="ga839312fb4de5e786daacb4fa071d61df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839312fb4de5e786daacb4fa071d61df">&#9670;&#160;</a></span>ucp_atomic_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> without the flag <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0">UCP_OP_ATTR_FIELD_REPLY_BUFFER</a> instead.</dd></dl>
<p>This routine posts an atomic memory operation to a remote value. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. Return from the function does not guarantee completion. A user must call <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga599c9b9272bfdd662afaa247d8e4dfd6">ucp_ep_flush_nb</a> or <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb</a> to guarantee that the remote value has been updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source operand for the atomic operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_size</td><td>Size of value in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a id="ga43a1a4a517797eb8c5c96ac8841437de" name="ga43a1a4a517797eb8c5c96ac8841437de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43a1a4a517797eb8c5c96ac8841437de">&#9670;&#160;</a></span>ucp_atomic_fetch_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_atomic_fetch_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___u_c_p___c_o_m_m.html#ga087e2cad02e84cf1230684362562aa46">ucp_atomic_op_nbx</a> with the flag <a class="el" href="group___u_c_p___c_o_m_m.html#gga67fae646dd1668efba6efe49a35a6610a8eb660399c093d89d5deae5c847019f0">UCP_OP_ATTR_FIELD_REPLY_BUFFER</a> instead.</dd></dl>
<p>This routine will post an atomic fetch operation to remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The routine is non-blocking and therefore returns immediately. However the actual atomic operation may be delayed. The atomic operation is not considered complete until the values in remote and local memory are completed. If the atomic operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the atomic operation. In other words, the completion of an atomic operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>result</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source operand for atomic operation. In the case of CSWAP this is the conditional for the swap. For SWAP this is the value to be placed in remote memory. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>Local memory address to store resulting fetch to. In the case of CSWAP the value in result will be swapped into the <em>remote_addr</em> if the condition is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_size</td><td>Size of value in bytes and pointer type for result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the send operation is completed. It is important to note that the call-back function is only invoked in a case when the operation cannot be completed in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jun 24 2025 15:51:05 for UCX by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
