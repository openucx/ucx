<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UCX: UCP Wake-up routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="UCX_Logo_80x80.png"/></td>
  <td id="projectalign">
   <div id="projectname">UCX<span id="projectnumber">&#160;1.19</span>
   </div>
   <div id="projectbrief">Unified Communication X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___u_c_p___w_a_k_e_u_p.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">UCP Wake-up routines<div class="ingroups"><a class="el" href="group___u_c_p___a_p_i.html">Unified Communication Protocol (UCP) API</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadf849649110fa338fd891548198a578b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, int *fd)</td></tr>
<tr class="memdesc:gadf849649110fa338fd891548198a578b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an event file descriptor for event notification.  <br /></td></tr>
<tr class="separator:gadf849649110fa338fd891548198a578b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d1fba4d8a2525b74174a8c344ae9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gaa6d1fba4d8a2525b74174a8c344ae9aa">ucp_worker_wait</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:gaa6d1fba4d8a2525b74174a8c344ae9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an event of the worker.  <br /></td></tr>
<tr class="separator:gaa6d1fba4d8a2525b74174a8c344ae9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b9a2ca2795f083e3b1250d698162aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_a_k_e_u_p.html#ga8b9a2ca2795f083e3b1250d698162aa6">ucp_worker_wait_mem</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *address)</td></tr>
<tr class="memdesc:ga8b9a2ca2795f083e3b1250d698162aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for memory update on the address.  <br /></td></tr>
<tr class="separator:ga8b9a2ca2795f083e3b1250d698162aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce97937294aae0f5f599d58d68904d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadce97937294aae0f5f599d58d68904d6">ucp_worker_arm</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:gadce97937294aae0f5f599d58d68904d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on event notification for the next event.  <br /></td></tr>
<tr class="separator:gadce97937294aae0f5f599d58d68904d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f83bf7620a2ea765fb7167c756b8e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_a_k_e_u_p.html#ga4f83bf7620a2ea765fb7167c756b8e48">ucp_worker_signal</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:ga4f83bf7620a2ea765fb7167c756b8e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause an event of the worker.  <br /></td></tr>
<tr class="separator:ga4f83bf7620a2ea765fb7167c756b8e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UCP Wake-up routines </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadf849649110fa338fd891548198a578b" name="gadf849649110fa338fd891548198a578b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf849649110fa338fd891548198a578b">&#9670;&#160;</a></span>ucp_worker_get_efd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_get_efd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a valid file descriptor for polling functions. The file descriptor will get signaled when an event occurs, as part of the wake-up mechanism. Signaling means a call to poll() or select() with this file descriptor will return at this point, with this descriptor marked as the reason (or one of the reasons) the function has returned. The user does not need to release the obtained file descriptor.</p>
<p>The wake-up mechanism exists to allow for the user process to register for notifications on events of the underlying interfaces, and wait until such occur. This is an alternative to repeated polling for request completion. The goal is to allow for waiting while consuming minimal resources from the system. This is recommended for cases where traffic is infrequent, and latency can be traded for lower resource consumption while waiting for it.</p>
<p>There are two alternative ways to use the wakeup mechanism: the first is the file descriptor obtained per worker (this function) and the second is the <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gaa6d1fba4d8a2525b74174a8c344ae9aa">ucp_worker_wait</a> function for waiting on the next event internally.</p>
<dl class="section note"><dt>Note</dt><dd>UCP <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#gaca5990bc015e7e9ac3e3be4e3611c5be">features</a> have to be triggered with <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ggaca5990bc015e7e9ac3e3be4e3611c5beabc3fea5aff6b7453e24235bceb102b5a">UCP_FEATURE_WAKEUP</a> to select proper transport</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker of notified events. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fd</td><td>File descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a7">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaa6d1fba4d8a2525b74174a8c344ae9aa" name="gaa6d1fba4d8a2525b74174a8c344ae9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d1fba4d8a2525b74174a8c344ae9aa">&#9670;&#160;</a></span>ucp_worker_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine waits (blocking) until an event has happened, as part of the wake-up mechanism.</p>
<p>This function is guaranteed to return only if new communication events occur on the <em>worker</em>. Therefore one must drain all existing events before waiting on the file descriptor. This can be achieved by calling <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a> repeatedly until it returns 0.</p>
<p>There are two alternative ways to use the wakeup mechanism. The first is by polling on a per-worker file descriptor obtained from <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a>. The second is by using this function to perform an internal wait for the next event associated with the specified worker.</p>
<dl class="section note"><dt>Note</dt><dd>During the blocking call the wake-up mechanism relies on other means of notification and may not progress some of the requests as it would when calling <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a> (which is not invoked in that duration).</dd>
<dd>
UCP <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#gaca5990bc015e7e9ac3e3be4e3611c5be">features</a> have to be triggered with <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ggaca5990bc015e7e9ac3e3be4e3611c5beabc3fea5aff6b7453e24235bceb102b5a">UCP_FEATURE_WAKEUP</a> to select proper transport</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker to wait for events on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a33">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga8b9a2ca2795f083e3b1250d698162aa6" name="ga8b9a2ca2795f083e3b1250d698162aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b9a2ca2795f083e3b1250d698162aa6">&#9670;&#160;</a></span>ucp_worker_wait_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_worker_wait_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine waits for a memory update at the local memory <em>address</em>. This is a blocking routine. The routine returns when the memory address is updated ("write") or an event occurs in the system.</p>
<p>This function is guaranteed to return only if new communication events occur on the worker or <em>address</em> is modified. Therefore one must drain all existing events before waiting on the file descriptor. This can be achieved by calling <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a> repeatedly until it returns 0.</p>
<dl class="section note"><dt>Note</dt><dd>This routine can be used by an application that executes busy-waiting loop checking for a memory update. Instead of continuous busy-waiting on an address the application can use <em>ucp_worker_wait_mem</em>, which may suspend execution until the memory is updated. The goal of the routine is to provide an opportunity for energy savings for architectures that support this functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker to wait for updates on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Local memory address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadce97937294aae0f5f599d58d68904d6" name="gadce97937294aae0f5f599d58d68904d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce97937294aae0f5f599d58d68904d6">&#9670;&#160;</a></span>ucp_worker_arm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_arm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine needs to be called before waiting on each notification on this worker, so will typically be called once the processing of the previous event is over, as part of the wake-up mechanism.</p>
<p>The worker must be armed before waiting on an event (must be re-armed after it has been signaled for reuse) with <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadce97937294aae0f5f599d58d68904d6">ucp_worker_arm</a>. The events triggering a signal of the file descriptor from <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a> depend on the interfaces used by the worker and defined in the transport layer, and typically represent a request completion or newly available resources. It can also be triggered by calling <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#ga4f83bf7620a2ea765fb7167c756b8e48">ucp_worker_signal</a> .</p>
<p>The file descriptor is guaranteed to become signaled only if new communication events occur on the <em>worker</em>. Therefore one must drain all existing events before waiting on the file descriptor. This can be achieved by calling <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a> repeatedly until it returns 0.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> application_initialization() {</div>
<div class="line"><span class="comment">// should be called once in application init flow and before</span></div>
<div class="line"><span class="comment">// process_communication() is used</span></div>
<div class="line">    ...</div>
<div class="line">    status = <a class="code hl_function" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a>(worker, &amp;fd);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> process_communication() {</div>
<div class="line"><span class="comment">// should be called every time need to wait for some condition such as</span></div>
<div class="line"><span class="comment">// ucp request completion in sleep mode.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (;;) {</div>
<div class="line">        <span class="comment">// check for stop condition as long as progress is made</span></div>
<div class="line">        <span class="keywordflow">if</span> (check_for_events()) {</div>
<div class="line">             <span class="keywordflow">break</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a>(worker)) {</div>
<div class="line">             <span class="keywordflow">continue</span>;                 <span class="comment">// some progress happened but condition not met</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// arm the worker and clean-up fd</span></div>
<div class="line">        status = <a class="code hl_function" href="group___u_c_p___w_a_k_e_u_p.html#gadce97937294aae0f5f599d58d68904d6">ucp_worker_arm</a>(worker);</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a">UCS_OK</a> == status) {</div>
<div class="line">            poll(&amp;fds, nfds, timeout);  <span class="comment">// wait for events (sleep mode)</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a331d8719f76965a4514684c570110105">UCS_ERR_BUSY</a> == status) {</div>
<div class="line">            <span class="keywordflow">continue</span>;                   <span class="comment">// could not arm, need to progress more</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            abort();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup___u_c_p___w_a_k_e_u_p_html_gadce97937294aae0f5f599d58d68904d6"><div class="ttname"><a href="group___u_c_p___w_a_k_e_u_p.html#gadce97937294aae0f5f599d58d68904d6">ucp_worker_arm</a></div><div class="ttdeci">ucs_status_t ucp_worker_arm(ucp_worker_h worker)</div><div class="ttdoc">Turn on event notification for the next event.</div></div>
<div class="ttc" id="agroup___u_c_p___w_a_k_e_u_p_html_gadf849649110fa338fd891548198a578b"><div class="ttname"><a href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a></div><div class="ttdeci">ucs_status_t ucp_worker_get_efd(ucp_worker_h worker, int *fd)</div><div class="ttdoc">Obtain an event file descriptor for event notification.</div></div>
<div class="ttc" id="agroup___u_c_p___w_o_r_k_e_r_html_ga340784a8528d4932916651460dc481c0"><div class="ttname"><a href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a></div><div class="ttdeci">unsigned ucp_worker_progress(ucp_worker_h worker)</div><div class="ttdoc">Progress all communications on a specific worker.</div></div>
<div class="ttc" id="agroup___u_c_s___r_e_s_o_u_r_c_e_html_gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a"><div class="ttname"><a href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a">UCS_OK</a></div><div class="ttdeci">@ UCS_OK</div><div class="ttdef"><b>Definition</b> status.h:47</div></div>
<div class="ttc" id="agroup___u_c_s___r_e_s_o_u_r_c_e_html_gga88ca72d7294772e7d2edb70a2df15558a331d8719f76965a4514684c570110105"><div class="ttname"><a href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a331d8719f76965a4514684c570110105">UCS_ERR_BUSY</a></div><div class="ttdeci">@ UCS_ERR_BUSY</div><div class="ttdef"><b>Definition</b> status.h:67</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>UCP <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#gaca5990bc015e7e9ac3e3be4e3611c5be">features</a> have to be triggered with <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ggaca5990bc015e7e9ac3e3be4e3611c5beabc3fea5aff6b7453e24235bceb102b5a">UCP_FEATURE_WAKEUP</a> to select proper transport</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker of notified events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a1a7fbae02ac33fb94f519c7c773f419a">UCS_OK</a> The operation completed successfully. File descriptor will be signaled by new events. </dd>
<dd>
<a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a331d8719f76965a4514684c570110105">UCS_ERR_BUSY</a> There are unprocessed events which prevent the file descriptor from being armed. These events should be removed by calling <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress()</a>. The operation is not completed. File descriptor will not be signaled by new events. </dd>
<dd>
<a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">Other</a> different error codes in case of issues. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a8">ucp_hello_world.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga4f83bf7620a2ea765fb7167c756b8e48" name="ga4f83bf7620a2ea765fb7167c756b8e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f83bf7620a2ea765fb7167c756b8e48">&#9670;&#160;</a></span>ucp_worker_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine signals that the event has happened, as part of the wake-up mechanism. This function causes a blocking call to <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gaa6d1fba4d8a2525b74174a8c344ae9aa">ucp_worker_wait</a> or waiting on a file descriptor from <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a> to return, even if no event from the underlying interfaces has taken place.</p>
<dl class="section note"><dt>Note</dt><dd>It's safe to use this routine from any thread, even if UCX is compiled without multi-threading support and/or initialized with any value of <a class="el" href="group___u_c_p___c_o_n_f_i_g.html#ac81f2d8a179df5fd39786a4b08b26faf">ucp_params_t::mt_workers_shared</a> and <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#a790642ea681ddd2b0935ad62f70e4ef1">ucp_worker_params_t::thread_mode</a> parameters</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker to wait for events on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jun 24 2025 15:51:04 for UCX by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
